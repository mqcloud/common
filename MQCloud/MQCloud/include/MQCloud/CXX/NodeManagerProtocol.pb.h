// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: NodeManagerProtocol.proto

#ifndef PROTOBUF_NodeManagerProtocol_2eproto__INCLUDED
#define PROTOBUF_NodeManagerProtocol_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2006000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2006001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)

namespace NodesManager {
namespace Protocol {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_NodeManagerProtocol_2eproto();
void protobuf_AssignDesc_NodeManagerProtocol_2eproto();
void protobuf_ShutdownFile_NodeManagerProtocol_2eproto();

class AdvertizeTopic;
class ConnectRequest;
class ConnectResponse;
class Disconnect;
class GetAllPublishersRequest;
class GetAllPublishersResponse;
class GetAllSubscribersRequest;
class GetAllSubscribersResponse;
class GetPublisherRequest;
class GetPublishersResponse;
class GetSubscriberRequest;
class GetSubscriberResponse;
class HeartBeat;
class OnAdvertisedTopic;
class OnNodeRejectedTopic;
class OnNodeUnavaliable;
class RejectTopic;
class Subscribe;
class UnSubscribe;

// ===================================================================

class AdvertizeTopic : public ::google::protobuf::Message {
 public:
  AdvertizeTopic();
  virtual ~AdvertizeTopic();

  AdvertizeTopic(const AdvertizeTopic& from);

  inline AdvertizeTopic& operator=(const AdvertizeTopic& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const AdvertizeTopic& default_instance();

  void Swap(AdvertizeTopic* other);

  // implements Message ----------------------------------------------

  AdvertizeTopic* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const AdvertizeTopic& from);
  void MergeFrom(const AdvertizeTopic& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string Pattern = 1;
  inline bool has_pattern() const;
  inline void clear_pattern();
  static const int kPatternFieldNumber = 1;
  inline const ::std::string& pattern() const;
  inline void set_pattern(const ::std::string& value);
  inline void set_pattern(const char* value);
  inline void set_pattern(const char* value, size_t size);
  inline ::std::string* mutable_pattern();
  inline ::std::string* release_pattern();
  inline void set_allocated_pattern(::std::string* pattern);

  // optional string Topic = 2;
  inline bool has_topic() const;
  inline void clear_topic();
  static const int kTopicFieldNumber = 2;
  inline const ::std::string& topic() const;
  inline void set_topic(const ::std::string& value);
  inline void set_topic(const char* value);
  inline void set_topic(const char* value, size_t size);
  inline ::std::string* mutable_topic();
  inline ::std::string* release_topic();
  inline void set_allocated_topic(::std::string* topic);

  // optional string BackEndName = 4;
  inline bool has_backendname() const;
  inline void clear_backendname();
  static const int kBackEndNameFieldNumber = 4;
  inline const ::std::string& backendname() const;
  inline void set_backendname(const ::std::string& value);
  inline void set_backendname(const char* value);
  inline void set_backendname(const char* value, size_t size);
  inline ::std::string* mutable_backendname();
  inline ::std::string* release_backendname();
  inline void set_allocated_backendname(::std::string* backendname);

  // @@protoc_insertion_point(class_scope:NodesManager.Protocol.AdvertizeTopic)
 private:
  inline void set_has_pattern();
  inline void clear_has_pattern();
  inline void set_has_topic();
  inline void clear_has_topic();
  inline void set_has_backendname();
  inline void clear_has_backendname();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* pattern_;
  ::std::string* topic_;
  ::std::string* backendname_;
  friend void  protobuf_AddDesc_NodeManagerProtocol_2eproto();
  friend void protobuf_AssignDesc_NodeManagerProtocol_2eproto();
  friend void protobuf_ShutdownFile_NodeManagerProtocol_2eproto();

  void InitAsDefaultInstance();
  static AdvertizeTopic* default_instance_;
};
// -------------------------------------------------------------------

class ConnectRequest : public ::google::protobuf::Message {
 public:
  ConnectRequest();
  virtual ~ConnectRequest();

  ConnectRequest(const ConnectRequest& from);

  inline ConnectRequest& operator=(const ConnectRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ConnectRequest& default_instance();

  void Swap(ConnectRequest* other);

  // implements Message ----------------------------------------------

  ConnectRequest* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ConnectRequest& from);
  void MergeFrom(const ConnectRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string NodeName = 1;
  inline bool has_nodename() const;
  inline void clear_nodename();
  static const int kNodeNameFieldNumber = 1;
  inline const ::std::string& nodename() const;
  inline void set_nodename(const ::std::string& value);
  inline void set_nodename(const char* value);
  inline void set_nodename(const char* value, size_t size);
  inline ::std::string* mutable_nodename();
  inline ::std::string* release_nodename();
  inline void set_allocated_nodename(::std::string* nodename);

  // @@protoc_insertion_point(class_scope:NodesManager.Protocol.ConnectRequest)
 private:
  inline void set_has_nodename();
  inline void clear_has_nodename();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* nodename_;
  friend void  protobuf_AddDesc_NodeManagerProtocol_2eproto();
  friend void protobuf_AssignDesc_NodeManagerProtocol_2eproto();
  friend void protobuf_ShutdownFile_NodeManagerProtocol_2eproto();

  void InitAsDefaultInstance();
  static ConnectRequest* default_instance_;
};
// -------------------------------------------------------------------

class ConnectResponse : public ::google::protobuf::Message {
 public:
  ConnectResponse();
  virtual ~ConnectResponse();

  ConnectResponse(const ConnectResponse& from);

  inline ConnectResponse& operator=(const ConnectResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ConnectResponse& default_instance();

  void Swap(ConnectResponse* other);

  // implements Message ----------------------------------------------

  ConnectResponse* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ConnectResponse& from);
  void MergeFrom(const ConnectResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string RealNodeName = 1;
  inline bool has_realnodename() const;
  inline void clear_realnodename();
  static const int kRealNodeNameFieldNumber = 1;
  inline const ::std::string& realnodename() const;
  inline void set_realnodename(const ::std::string& value);
  inline void set_realnodename(const char* value);
  inline void set_realnodename(const char* value, size_t size);
  inline ::std::string* mutable_realnodename();
  inline ::std::string* release_realnodename();
  inline void set_allocated_realnodename(::std::string* realnodename);

  // optional int32 HeartBeatRateMs = 2 [default = 0];
  inline bool has_heartbeatratems() const;
  inline void clear_heartbeatratems();
  static const int kHeartBeatRateMsFieldNumber = 2;
  inline ::google::protobuf::int32 heartbeatratems() const;
  inline void set_heartbeatratems(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:NodesManager.Protocol.ConnectResponse)
 private:
  inline void set_has_realnodename();
  inline void clear_has_realnodename();
  inline void set_has_heartbeatratems();
  inline void clear_has_heartbeatratems();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* realnodename_;
  ::google::protobuf::int32 heartbeatratems_;
  friend void  protobuf_AddDesc_NodeManagerProtocol_2eproto();
  friend void protobuf_AssignDesc_NodeManagerProtocol_2eproto();
  friend void protobuf_ShutdownFile_NodeManagerProtocol_2eproto();

  void InitAsDefaultInstance();
  static ConnectResponse* default_instance_;
};
// -------------------------------------------------------------------

class Disconnect : public ::google::protobuf::Message {
 public:
  Disconnect();
  virtual ~Disconnect();

  Disconnect(const Disconnect& from);

  inline Disconnect& operator=(const Disconnect& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Disconnect& default_instance();

  void Swap(Disconnect* other);

  // implements Message ----------------------------------------------

  Disconnect* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Disconnect& from);
  void MergeFrom(const Disconnect& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:NodesManager.Protocol.Disconnect)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_NodeManagerProtocol_2eproto();
  friend void protobuf_AssignDesc_NodeManagerProtocol_2eproto();
  friend void protobuf_ShutdownFile_NodeManagerProtocol_2eproto();

  void InitAsDefaultInstance();
  static Disconnect* default_instance_;
};
// -------------------------------------------------------------------

class GetAllPublishersRequest : public ::google::protobuf::Message {
 public:
  GetAllPublishersRequest();
  virtual ~GetAllPublishersRequest();

  GetAllPublishersRequest(const GetAllPublishersRequest& from);

  inline GetAllPublishersRequest& operator=(const GetAllPublishersRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const GetAllPublishersRequest& default_instance();

  void Swap(GetAllPublishersRequest* other);

  // implements Message ----------------------------------------------

  GetAllPublishersRequest* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const GetAllPublishersRequest& from);
  void MergeFrom(const GetAllPublishersRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 RequestId = 1 [default = 0];
  inline bool has_requestid() const;
  inline void clear_requestid();
  static const int kRequestIdFieldNumber = 1;
  inline ::google::protobuf::int32 requestid() const;
  inline void set_requestid(::google::protobuf::int32 value);

  // optional string Pattern = 2;
  inline bool has_pattern() const;
  inline void clear_pattern();
  static const int kPatternFieldNumber = 2;
  inline const ::std::string& pattern() const;
  inline void set_pattern(const ::std::string& value);
  inline void set_pattern(const char* value);
  inline void set_pattern(const char* value, size_t size);
  inline ::std::string* mutable_pattern();
  inline ::std::string* release_pattern();
  inline void set_allocated_pattern(::std::string* pattern);

  // optional string BackEndName = 3;
  inline bool has_backendname() const;
  inline void clear_backendname();
  static const int kBackEndNameFieldNumber = 3;
  inline const ::std::string& backendname() const;
  inline void set_backendname(const ::std::string& value);
  inline void set_backendname(const char* value);
  inline void set_backendname(const char* value, size_t size);
  inline ::std::string* mutable_backendname();
  inline ::std::string* release_backendname();
  inline void set_allocated_backendname(::std::string* backendname);

  // optional string Topic = 4;
  inline bool has_topic() const;
  inline void clear_topic();
  static const int kTopicFieldNumber = 4;
  inline const ::std::string& topic() const;
  inline void set_topic(const ::std::string& value);
  inline void set_topic(const char* value);
  inline void set_topic(const char* value, size_t size);
  inline ::std::string* mutable_topic();
  inline ::std::string* release_topic();
  inline void set_allocated_topic(::std::string* topic);

  // @@protoc_insertion_point(class_scope:NodesManager.Protocol.GetAllPublishersRequest)
 private:
  inline void set_has_requestid();
  inline void clear_has_requestid();
  inline void set_has_pattern();
  inline void clear_has_pattern();
  inline void set_has_backendname();
  inline void clear_has_backendname();
  inline void set_has_topic();
  inline void clear_has_topic();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* pattern_;
  ::std::string* backendname_;
  ::std::string* topic_;
  ::google::protobuf::int32 requestid_;
  friend void  protobuf_AddDesc_NodeManagerProtocol_2eproto();
  friend void protobuf_AssignDesc_NodeManagerProtocol_2eproto();
  friend void protobuf_ShutdownFile_NodeManagerProtocol_2eproto();

  void InitAsDefaultInstance();
  static GetAllPublishersRequest* default_instance_;
};
// -------------------------------------------------------------------

class GetAllPublishersResponse : public ::google::protobuf::Message {
 public:
  GetAllPublishersResponse();
  virtual ~GetAllPublishersResponse();

  GetAllPublishersResponse(const GetAllPublishersResponse& from);

  inline GetAllPublishersResponse& operator=(const GetAllPublishersResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const GetAllPublishersResponse& default_instance();

  void Swap(GetAllPublishersResponse* other);

  // implements Message ----------------------------------------------

  GetAllPublishersResponse* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const GetAllPublishersResponse& from);
  void MergeFrom(const GetAllPublishersResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 RequestId = 1 [default = 0];
  inline bool has_requestid() const;
  inline void clear_requestid();
  static const int kRequestIdFieldNumber = 1;
  inline ::google::protobuf::int32 requestid() const;
  inline void set_requestid(::google::protobuf::int32 value);

  // repeated string Nodes = 2;
  inline int nodes_size() const;
  inline void clear_nodes();
  static const int kNodesFieldNumber = 2;
  inline const ::std::string& nodes(int index) const;
  inline ::std::string* mutable_nodes(int index);
  inline void set_nodes(int index, const ::std::string& value);
  inline void set_nodes(int index, const char* value);
  inline void set_nodes(int index, const char* value, size_t size);
  inline ::std::string* add_nodes();
  inline void add_nodes(const ::std::string& value);
  inline void add_nodes(const char* value);
  inline void add_nodes(const char* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& nodes() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_nodes();

  // @@protoc_insertion_point(class_scope:NodesManager.Protocol.GetAllPublishersResponse)
 private:
  inline void set_has_requestid();
  inline void clear_has_requestid();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::std::string> nodes_;
  ::google::protobuf::int32 requestid_;
  friend void  protobuf_AddDesc_NodeManagerProtocol_2eproto();
  friend void protobuf_AssignDesc_NodeManagerProtocol_2eproto();
  friend void protobuf_ShutdownFile_NodeManagerProtocol_2eproto();

  void InitAsDefaultInstance();
  static GetAllPublishersResponse* default_instance_;
};
// -------------------------------------------------------------------

class GetAllSubscribersRequest : public ::google::protobuf::Message {
 public:
  GetAllSubscribersRequest();
  virtual ~GetAllSubscribersRequest();

  GetAllSubscribersRequest(const GetAllSubscribersRequest& from);

  inline GetAllSubscribersRequest& operator=(const GetAllSubscribersRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const GetAllSubscribersRequest& default_instance();

  void Swap(GetAllSubscribersRequest* other);

  // implements Message ----------------------------------------------

  GetAllSubscribersRequest* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const GetAllSubscribersRequest& from);
  void MergeFrom(const GetAllSubscribersRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 RequestId = 1 [default = 0];
  inline bool has_requestid() const;
  inline void clear_requestid();
  static const int kRequestIdFieldNumber = 1;
  inline ::google::protobuf::int32 requestid() const;
  inline void set_requestid(::google::protobuf::int32 value);

  // optional string Pattern = 2;
  inline bool has_pattern() const;
  inline void clear_pattern();
  static const int kPatternFieldNumber = 2;
  inline const ::std::string& pattern() const;
  inline void set_pattern(const ::std::string& value);
  inline void set_pattern(const char* value);
  inline void set_pattern(const char* value, size_t size);
  inline ::std::string* mutable_pattern();
  inline ::std::string* release_pattern();
  inline void set_allocated_pattern(::std::string* pattern);

  // optional string BackEndName = 3;
  inline bool has_backendname() const;
  inline void clear_backendname();
  static const int kBackEndNameFieldNumber = 3;
  inline const ::std::string& backendname() const;
  inline void set_backendname(const ::std::string& value);
  inline void set_backendname(const char* value);
  inline void set_backendname(const char* value, size_t size);
  inline ::std::string* mutable_backendname();
  inline ::std::string* release_backendname();
  inline void set_allocated_backendname(::std::string* backendname);

  // optional string Topic = 4;
  inline bool has_topic() const;
  inline void clear_topic();
  static const int kTopicFieldNumber = 4;
  inline const ::std::string& topic() const;
  inline void set_topic(const ::std::string& value);
  inline void set_topic(const char* value);
  inline void set_topic(const char* value, size_t size);
  inline ::std::string* mutable_topic();
  inline ::std::string* release_topic();
  inline void set_allocated_topic(::std::string* topic);

  // @@protoc_insertion_point(class_scope:NodesManager.Protocol.GetAllSubscribersRequest)
 private:
  inline void set_has_requestid();
  inline void clear_has_requestid();
  inline void set_has_pattern();
  inline void clear_has_pattern();
  inline void set_has_backendname();
  inline void clear_has_backendname();
  inline void set_has_topic();
  inline void clear_has_topic();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* pattern_;
  ::std::string* backendname_;
  ::std::string* topic_;
  ::google::protobuf::int32 requestid_;
  friend void  protobuf_AddDesc_NodeManagerProtocol_2eproto();
  friend void protobuf_AssignDesc_NodeManagerProtocol_2eproto();
  friend void protobuf_ShutdownFile_NodeManagerProtocol_2eproto();

  void InitAsDefaultInstance();
  static GetAllSubscribersRequest* default_instance_;
};
// -------------------------------------------------------------------

class GetAllSubscribersResponse : public ::google::protobuf::Message {
 public:
  GetAllSubscribersResponse();
  virtual ~GetAllSubscribersResponse();

  GetAllSubscribersResponse(const GetAllSubscribersResponse& from);

  inline GetAllSubscribersResponse& operator=(const GetAllSubscribersResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const GetAllSubscribersResponse& default_instance();

  void Swap(GetAllSubscribersResponse* other);

  // implements Message ----------------------------------------------

  GetAllSubscribersResponse* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const GetAllSubscribersResponse& from);
  void MergeFrom(const GetAllSubscribersResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 RequestId = 1 [default = 0];
  inline bool has_requestid() const;
  inline void clear_requestid();
  static const int kRequestIdFieldNumber = 1;
  inline ::google::protobuf::int32 requestid() const;
  inline void set_requestid(::google::protobuf::int32 value);

  // repeated string Nodes = 2;
  inline int nodes_size() const;
  inline void clear_nodes();
  static const int kNodesFieldNumber = 2;
  inline const ::std::string& nodes(int index) const;
  inline ::std::string* mutable_nodes(int index);
  inline void set_nodes(int index, const ::std::string& value);
  inline void set_nodes(int index, const char* value);
  inline void set_nodes(int index, const char* value, size_t size);
  inline ::std::string* add_nodes();
  inline void add_nodes(const ::std::string& value);
  inline void add_nodes(const char* value);
  inline void add_nodes(const char* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& nodes() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_nodes();

  // @@protoc_insertion_point(class_scope:NodesManager.Protocol.GetAllSubscribersResponse)
 private:
  inline void set_has_requestid();
  inline void clear_has_requestid();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::std::string> nodes_;
  ::google::protobuf::int32 requestid_;
  friend void  protobuf_AddDesc_NodeManagerProtocol_2eproto();
  friend void protobuf_AssignDesc_NodeManagerProtocol_2eproto();
  friend void protobuf_ShutdownFile_NodeManagerProtocol_2eproto();

  void InitAsDefaultInstance();
  static GetAllSubscribersResponse* default_instance_;
};
// -------------------------------------------------------------------

class GetPublisherRequest : public ::google::protobuf::Message {
 public:
  GetPublisherRequest();
  virtual ~GetPublisherRequest();

  GetPublisherRequest(const GetPublisherRequest& from);

  inline GetPublisherRequest& operator=(const GetPublisherRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const GetPublisherRequest& default_instance();

  void Swap(GetPublisherRequest* other);

  // implements Message ----------------------------------------------

  GetPublisherRequest* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const GetPublisherRequest& from);
  void MergeFrom(const GetPublisherRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 RequestId = 1 [default = 0];
  inline bool has_requestid() const;
  inline void clear_requestid();
  static const int kRequestIdFieldNumber = 1;
  inline ::google::protobuf::int32 requestid() const;
  inline void set_requestid(::google::protobuf::int32 value);

  // optional string Pattern = 2;
  inline bool has_pattern() const;
  inline void clear_pattern();
  static const int kPatternFieldNumber = 2;
  inline const ::std::string& pattern() const;
  inline void set_pattern(const ::std::string& value);
  inline void set_pattern(const char* value);
  inline void set_pattern(const char* value, size_t size);
  inline ::std::string* mutable_pattern();
  inline ::std::string* release_pattern();
  inline void set_allocated_pattern(::std::string* pattern);

  // optional string BackEndName = 3;
  inline bool has_backendname() const;
  inline void clear_backendname();
  static const int kBackEndNameFieldNumber = 3;
  inline const ::std::string& backendname() const;
  inline void set_backendname(const ::std::string& value);
  inline void set_backendname(const char* value);
  inline void set_backendname(const char* value, size_t size);
  inline ::std::string* mutable_backendname();
  inline ::std::string* release_backendname();
  inline void set_allocated_backendname(::std::string* backendname);

  // optional string Topic = 4;
  inline bool has_topic() const;
  inline void clear_topic();
  static const int kTopicFieldNumber = 4;
  inline const ::std::string& topic() const;
  inline void set_topic(const ::std::string& value);
  inline void set_topic(const char* value);
  inline void set_topic(const char* value, size_t size);
  inline ::std::string* mutable_topic();
  inline ::std::string* release_topic();
  inline void set_allocated_topic(::std::string* topic);

  // @@protoc_insertion_point(class_scope:NodesManager.Protocol.GetPublisherRequest)
 private:
  inline void set_has_requestid();
  inline void clear_has_requestid();
  inline void set_has_pattern();
  inline void clear_has_pattern();
  inline void set_has_backendname();
  inline void clear_has_backendname();
  inline void set_has_topic();
  inline void clear_has_topic();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* pattern_;
  ::std::string* backendname_;
  ::std::string* topic_;
  ::google::protobuf::int32 requestid_;
  friend void  protobuf_AddDesc_NodeManagerProtocol_2eproto();
  friend void protobuf_AssignDesc_NodeManagerProtocol_2eproto();
  friend void protobuf_ShutdownFile_NodeManagerProtocol_2eproto();

  void InitAsDefaultInstance();
  static GetPublisherRequest* default_instance_;
};
// -------------------------------------------------------------------

class GetPublishersResponse : public ::google::protobuf::Message {
 public:
  GetPublishersResponse();
  virtual ~GetPublishersResponse();

  GetPublishersResponse(const GetPublishersResponse& from);

  inline GetPublishersResponse& operator=(const GetPublishersResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const GetPublishersResponse& default_instance();

  void Swap(GetPublishersResponse* other);

  // implements Message ----------------------------------------------

  GetPublishersResponse* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const GetPublishersResponse& from);
  void MergeFrom(const GetPublishersResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 RequestId = 1 [default = 0];
  inline bool has_requestid() const;
  inline void clear_requestid();
  static const int kRequestIdFieldNumber = 1;
  inline ::google::protobuf::int32 requestid() const;
  inline void set_requestid(::google::protobuf::int32 value);

  // repeated string Nodes = 2;
  inline int nodes_size() const;
  inline void clear_nodes();
  static const int kNodesFieldNumber = 2;
  inline const ::std::string& nodes(int index) const;
  inline ::std::string* mutable_nodes(int index);
  inline void set_nodes(int index, const ::std::string& value);
  inline void set_nodes(int index, const char* value);
  inline void set_nodes(int index, const char* value, size_t size);
  inline ::std::string* add_nodes();
  inline void add_nodes(const ::std::string& value);
  inline void add_nodes(const char* value);
  inline void add_nodes(const char* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& nodes() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_nodes();

  // @@protoc_insertion_point(class_scope:NodesManager.Protocol.GetPublishersResponse)
 private:
  inline void set_has_requestid();
  inline void clear_has_requestid();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::std::string> nodes_;
  ::google::protobuf::int32 requestid_;
  friend void  protobuf_AddDesc_NodeManagerProtocol_2eproto();
  friend void protobuf_AssignDesc_NodeManagerProtocol_2eproto();
  friend void protobuf_ShutdownFile_NodeManagerProtocol_2eproto();

  void InitAsDefaultInstance();
  static GetPublishersResponse* default_instance_;
};
// -------------------------------------------------------------------

class GetSubscriberRequest : public ::google::protobuf::Message {
 public:
  GetSubscriberRequest();
  virtual ~GetSubscriberRequest();

  GetSubscriberRequest(const GetSubscriberRequest& from);

  inline GetSubscriberRequest& operator=(const GetSubscriberRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const GetSubscriberRequest& default_instance();

  void Swap(GetSubscriberRequest* other);

  // implements Message ----------------------------------------------

  GetSubscriberRequest* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const GetSubscriberRequest& from);
  void MergeFrom(const GetSubscriberRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 RequestId = 1 [default = 0];
  inline bool has_requestid() const;
  inline void clear_requestid();
  static const int kRequestIdFieldNumber = 1;
  inline ::google::protobuf::int32 requestid() const;
  inline void set_requestid(::google::protobuf::int32 value);

  // optional string Pattern = 2;
  inline bool has_pattern() const;
  inline void clear_pattern();
  static const int kPatternFieldNumber = 2;
  inline const ::std::string& pattern() const;
  inline void set_pattern(const ::std::string& value);
  inline void set_pattern(const char* value);
  inline void set_pattern(const char* value, size_t size);
  inline ::std::string* mutable_pattern();
  inline ::std::string* release_pattern();
  inline void set_allocated_pattern(::std::string* pattern);

  // optional string BackEndName = 3;
  inline bool has_backendname() const;
  inline void clear_backendname();
  static const int kBackEndNameFieldNumber = 3;
  inline const ::std::string& backendname() const;
  inline void set_backendname(const ::std::string& value);
  inline void set_backendname(const char* value);
  inline void set_backendname(const char* value, size_t size);
  inline ::std::string* mutable_backendname();
  inline ::std::string* release_backendname();
  inline void set_allocated_backendname(::std::string* backendname);

  // optional string Topic = 4;
  inline bool has_topic() const;
  inline void clear_topic();
  static const int kTopicFieldNumber = 4;
  inline const ::std::string& topic() const;
  inline void set_topic(const ::std::string& value);
  inline void set_topic(const char* value);
  inline void set_topic(const char* value, size_t size);
  inline ::std::string* mutable_topic();
  inline ::std::string* release_topic();
  inline void set_allocated_topic(::std::string* topic);

  // @@protoc_insertion_point(class_scope:NodesManager.Protocol.GetSubscriberRequest)
 private:
  inline void set_has_requestid();
  inline void clear_has_requestid();
  inline void set_has_pattern();
  inline void clear_has_pattern();
  inline void set_has_backendname();
  inline void clear_has_backendname();
  inline void set_has_topic();
  inline void clear_has_topic();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* pattern_;
  ::std::string* backendname_;
  ::std::string* topic_;
  ::google::protobuf::int32 requestid_;
  friend void  protobuf_AddDesc_NodeManagerProtocol_2eproto();
  friend void protobuf_AssignDesc_NodeManagerProtocol_2eproto();
  friend void protobuf_ShutdownFile_NodeManagerProtocol_2eproto();

  void InitAsDefaultInstance();
  static GetSubscriberRequest* default_instance_;
};
// -------------------------------------------------------------------

class GetSubscriberResponse : public ::google::protobuf::Message {
 public:
  GetSubscriberResponse();
  virtual ~GetSubscriberResponse();

  GetSubscriberResponse(const GetSubscriberResponse& from);

  inline GetSubscriberResponse& operator=(const GetSubscriberResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const GetSubscriberResponse& default_instance();

  void Swap(GetSubscriberResponse* other);

  // implements Message ----------------------------------------------

  GetSubscriberResponse* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const GetSubscriberResponse& from);
  void MergeFrom(const GetSubscriberResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 RequestId = 1 [default = 0];
  inline bool has_requestid() const;
  inline void clear_requestid();
  static const int kRequestIdFieldNumber = 1;
  inline ::google::protobuf::int32 requestid() const;
  inline void set_requestid(::google::protobuf::int32 value);

  // optional string Node = 2;
  inline bool has_node() const;
  inline void clear_node();
  static const int kNodeFieldNumber = 2;
  inline const ::std::string& node() const;
  inline void set_node(const ::std::string& value);
  inline void set_node(const char* value);
  inline void set_node(const char* value, size_t size);
  inline ::std::string* mutable_node();
  inline ::std::string* release_node();
  inline void set_allocated_node(::std::string* node);

  // @@protoc_insertion_point(class_scope:NodesManager.Protocol.GetSubscriberResponse)
 private:
  inline void set_has_requestid();
  inline void clear_has_requestid();
  inline void set_has_node();
  inline void clear_has_node();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* node_;
  ::google::protobuf::int32 requestid_;
  friend void  protobuf_AddDesc_NodeManagerProtocol_2eproto();
  friend void protobuf_AssignDesc_NodeManagerProtocol_2eproto();
  friend void protobuf_ShutdownFile_NodeManagerProtocol_2eproto();

  void InitAsDefaultInstance();
  static GetSubscriberResponse* default_instance_;
};
// -------------------------------------------------------------------

class HeartBeat : public ::google::protobuf::Message {
 public:
  HeartBeat();
  virtual ~HeartBeat();

  HeartBeat(const HeartBeat& from);

  inline HeartBeat& operator=(const HeartBeat& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const HeartBeat& default_instance();

  void Swap(HeartBeat* other);

  // implements Message ----------------------------------------------

  HeartBeat* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const HeartBeat& from);
  void MergeFrom(const HeartBeat& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:NodesManager.Protocol.HeartBeat)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_NodeManagerProtocol_2eproto();
  friend void protobuf_AssignDesc_NodeManagerProtocol_2eproto();
  friend void protobuf_ShutdownFile_NodeManagerProtocol_2eproto();

  void InitAsDefaultInstance();
  static HeartBeat* default_instance_;
};
// -------------------------------------------------------------------

class OnAdvertisedTopic : public ::google::protobuf::Message {
 public:
  OnAdvertisedTopic();
  virtual ~OnAdvertisedTopic();

  OnAdvertisedTopic(const OnAdvertisedTopic& from);

  inline OnAdvertisedTopic& operator=(const OnAdvertisedTopic& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const OnAdvertisedTopic& default_instance();

  void Swap(OnAdvertisedTopic* other);

  // implements Message ----------------------------------------------

  OnAdvertisedTopic* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const OnAdvertisedTopic& from);
  void MergeFrom(const OnAdvertisedTopic& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string Node = 1;
  inline bool has_node() const;
  inline void clear_node();
  static const int kNodeFieldNumber = 1;
  inline const ::std::string& node() const;
  inline void set_node(const ::std::string& value);
  inline void set_node(const char* value);
  inline void set_node(const char* value, size_t size);
  inline ::std::string* mutable_node();
  inline ::std::string* release_node();
  inline void set_allocated_node(::std::string* node);

  // optional string Pattern = 2;
  inline bool has_pattern() const;
  inline void clear_pattern();
  static const int kPatternFieldNumber = 2;
  inline const ::std::string& pattern() const;
  inline void set_pattern(const ::std::string& value);
  inline void set_pattern(const char* value);
  inline void set_pattern(const char* value, size_t size);
  inline ::std::string* mutable_pattern();
  inline ::std::string* release_pattern();
  inline void set_allocated_pattern(::std::string* pattern);

  // optional string Topic = 3;
  inline bool has_topic() const;
  inline void clear_topic();
  static const int kTopicFieldNumber = 3;
  inline const ::std::string& topic() const;
  inline void set_topic(const ::std::string& value);
  inline void set_topic(const char* value);
  inline void set_topic(const char* value, size_t size);
  inline ::std::string* mutable_topic();
  inline ::std::string* release_topic();
  inline void set_allocated_topic(::std::string* topic);

  // optional string BackEndName = 4;
  inline bool has_backendname() const;
  inline void clear_backendname();
  static const int kBackEndNameFieldNumber = 4;
  inline const ::std::string& backendname() const;
  inline void set_backendname(const ::std::string& value);
  inline void set_backendname(const char* value);
  inline void set_backendname(const char* value, size_t size);
  inline ::std::string* mutable_backendname();
  inline ::std::string* release_backendname();
  inline void set_allocated_backendname(::std::string* backendname);

  // @@protoc_insertion_point(class_scope:NodesManager.Protocol.OnAdvertisedTopic)
 private:
  inline void set_has_node();
  inline void clear_has_node();
  inline void set_has_pattern();
  inline void clear_has_pattern();
  inline void set_has_topic();
  inline void clear_has_topic();
  inline void set_has_backendname();
  inline void clear_has_backendname();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* node_;
  ::std::string* pattern_;
  ::std::string* topic_;
  ::std::string* backendname_;
  friend void  protobuf_AddDesc_NodeManagerProtocol_2eproto();
  friend void protobuf_AssignDesc_NodeManagerProtocol_2eproto();
  friend void protobuf_ShutdownFile_NodeManagerProtocol_2eproto();

  void InitAsDefaultInstance();
  static OnAdvertisedTopic* default_instance_;
};
// -------------------------------------------------------------------

class OnNodeRejectedTopic : public ::google::protobuf::Message {
 public:
  OnNodeRejectedTopic();
  virtual ~OnNodeRejectedTopic();

  OnNodeRejectedTopic(const OnNodeRejectedTopic& from);

  inline OnNodeRejectedTopic& operator=(const OnNodeRejectedTopic& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const OnNodeRejectedTopic& default_instance();

  void Swap(OnNodeRejectedTopic* other);

  // implements Message ----------------------------------------------

  OnNodeRejectedTopic* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const OnNodeRejectedTopic& from);
  void MergeFrom(const OnNodeRejectedTopic& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string Node = 1;
  inline bool has_node() const;
  inline void clear_node();
  static const int kNodeFieldNumber = 1;
  inline const ::std::string& node() const;
  inline void set_node(const ::std::string& value);
  inline void set_node(const char* value);
  inline void set_node(const char* value, size_t size);
  inline ::std::string* mutable_node();
  inline ::std::string* release_node();
  inline void set_allocated_node(::std::string* node);

  // optional string Pattern = 2;
  inline bool has_pattern() const;
  inline void clear_pattern();
  static const int kPatternFieldNumber = 2;
  inline const ::std::string& pattern() const;
  inline void set_pattern(const ::std::string& value);
  inline void set_pattern(const char* value);
  inline void set_pattern(const char* value, size_t size);
  inline ::std::string* mutable_pattern();
  inline ::std::string* release_pattern();
  inline void set_allocated_pattern(::std::string* pattern);

  // optional string Topic = 3;
  inline bool has_topic() const;
  inline void clear_topic();
  static const int kTopicFieldNumber = 3;
  inline const ::std::string& topic() const;
  inline void set_topic(const ::std::string& value);
  inline void set_topic(const char* value);
  inline void set_topic(const char* value, size_t size);
  inline ::std::string* mutable_topic();
  inline ::std::string* release_topic();
  inline void set_allocated_topic(::std::string* topic);

  // optional string BackEndName = 4;
  inline bool has_backendname() const;
  inline void clear_backendname();
  static const int kBackEndNameFieldNumber = 4;
  inline const ::std::string& backendname() const;
  inline void set_backendname(const ::std::string& value);
  inline void set_backendname(const char* value);
  inline void set_backendname(const char* value, size_t size);
  inline ::std::string* mutable_backendname();
  inline ::std::string* release_backendname();
  inline void set_allocated_backendname(::std::string* backendname);

  // @@protoc_insertion_point(class_scope:NodesManager.Protocol.OnNodeRejectedTopic)
 private:
  inline void set_has_node();
  inline void clear_has_node();
  inline void set_has_pattern();
  inline void clear_has_pattern();
  inline void set_has_topic();
  inline void clear_has_topic();
  inline void set_has_backendname();
  inline void clear_has_backendname();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* node_;
  ::std::string* pattern_;
  ::std::string* topic_;
  ::std::string* backendname_;
  friend void  protobuf_AddDesc_NodeManagerProtocol_2eproto();
  friend void protobuf_AssignDesc_NodeManagerProtocol_2eproto();
  friend void protobuf_ShutdownFile_NodeManagerProtocol_2eproto();

  void InitAsDefaultInstance();
  static OnNodeRejectedTopic* default_instance_;
};
// -------------------------------------------------------------------

class OnNodeUnavaliable : public ::google::protobuf::Message {
 public:
  OnNodeUnavaliable();
  virtual ~OnNodeUnavaliable();

  OnNodeUnavaliable(const OnNodeUnavaliable& from);

  inline OnNodeUnavaliable& operator=(const OnNodeUnavaliable& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const OnNodeUnavaliable& default_instance();

  void Swap(OnNodeUnavaliable* other);

  // implements Message ----------------------------------------------

  OnNodeUnavaliable* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const OnNodeUnavaliable& from);
  void MergeFrom(const OnNodeUnavaliable& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string Node = 1;
  inline bool has_node() const;
  inline void clear_node();
  static const int kNodeFieldNumber = 1;
  inline const ::std::string& node() const;
  inline void set_node(const ::std::string& value);
  inline void set_node(const char* value);
  inline void set_node(const char* value, size_t size);
  inline ::std::string* mutable_node();
  inline ::std::string* release_node();
  inline void set_allocated_node(::std::string* node);

  // optional string Pattern = 2;
  inline bool has_pattern() const;
  inline void clear_pattern();
  static const int kPatternFieldNumber = 2;
  inline const ::std::string& pattern() const;
  inline void set_pattern(const ::std::string& value);
  inline void set_pattern(const char* value);
  inline void set_pattern(const char* value, size_t size);
  inline ::std::string* mutable_pattern();
  inline ::std::string* release_pattern();
  inline void set_allocated_pattern(::std::string* pattern);

  // optional string Topic = 3;
  inline bool has_topic() const;
  inline void clear_topic();
  static const int kTopicFieldNumber = 3;
  inline const ::std::string& topic() const;
  inline void set_topic(const ::std::string& value);
  inline void set_topic(const char* value);
  inline void set_topic(const char* value, size_t size);
  inline ::std::string* mutable_topic();
  inline ::std::string* release_topic();
  inline void set_allocated_topic(::std::string* topic);

  // optional string BackEndName = 4;
  inline bool has_backendname() const;
  inline void clear_backendname();
  static const int kBackEndNameFieldNumber = 4;
  inline const ::std::string& backendname() const;
  inline void set_backendname(const ::std::string& value);
  inline void set_backendname(const char* value);
  inline void set_backendname(const char* value, size_t size);
  inline ::std::string* mutable_backendname();
  inline ::std::string* release_backendname();
  inline void set_allocated_backendname(::std::string* backendname);

  // @@protoc_insertion_point(class_scope:NodesManager.Protocol.OnNodeUnavaliable)
 private:
  inline void set_has_node();
  inline void clear_has_node();
  inline void set_has_pattern();
  inline void clear_has_pattern();
  inline void set_has_topic();
  inline void clear_has_topic();
  inline void set_has_backendname();
  inline void clear_has_backendname();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* node_;
  ::std::string* pattern_;
  ::std::string* topic_;
  ::std::string* backendname_;
  friend void  protobuf_AddDesc_NodeManagerProtocol_2eproto();
  friend void protobuf_AssignDesc_NodeManagerProtocol_2eproto();
  friend void protobuf_ShutdownFile_NodeManagerProtocol_2eproto();

  void InitAsDefaultInstance();
  static OnNodeUnavaliable* default_instance_;
};
// -------------------------------------------------------------------

class RejectTopic : public ::google::protobuf::Message {
 public:
  RejectTopic();
  virtual ~RejectTopic();

  RejectTopic(const RejectTopic& from);

  inline RejectTopic& operator=(const RejectTopic& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RejectTopic& default_instance();

  void Swap(RejectTopic* other);

  // implements Message ----------------------------------------------

  RejectTopic* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RejectTopic& from);
  void MergeFrom(const RejectTopic& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string Pattern = 1;
  inline bool has_pattern() const;
  inline void clear_pattern();
  static const int kPatternFieldNumber = 1;
  inline const ::std::string& pattern() const;
  inline void set_pattern(const ::std::string& value);
  inline void set_pattern(const char* value);
  inline void set_pattern(const char* value, size_t size);
  inline ::std::string* mutable_pattern();
  inline ::std::string* release_pattern();
  inline void set_allocated_pattern(::std::string* pattern);

  // optional string Topic = 2;
  inline bool has_topic() const;
  inline void clear_topic();
  static const int kTopicFieldNumber = 2;
  inline const ::std::string& topic() const;
  inline void set_topic(const ::std::string& value);
  inline void set_topic(const char* value);
  inline void set_topic(const char* value, size_t size);
  inline ::std::string* mutable_topic();
  inline ::std::string* release_topic();
  inline void set_allocated_topic(::std::string* topic);

  // optional string BackEndName = 3;
  inline bool has_backendname() const;
  inline void clear_backendname();
  static const int kBackEndNameFieldNumber = 3;
  inline const ::std::string& backendname() const;
  inline void set_backendname(const ::std::string& value);
  inline void set_backendname(const char* value);
  inline void set_backendname(const char* value, size_t size);
  inline ::std::string* mutable_backendname();
  inline ::std::string* release_backendname();
  inline void set_allocated_backendname(::std::string* backendname);

  // @@protoc_insertion_point(class_scope:NodesManager.Protocol.RejectTopic)
 private:
  inline void set_has_pattern();
  inline void clear_has_pattern();
  inline void set_has_topic();
  inline void clear_has_topic();
  inline void set_has_backendname();
  inline void clear_has_backendname();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* pattern_;
  ::std::string* topic_;
  ::std::string* backendname_;
  friend void  protobuf_AddDesc_NodeManagerProtocol_2eproto();
  friend void protobuf_AssignDesc_NodeManagerProtocol_2eproto();
  friend void protobuf_ShutdownFile_NodeManagerProtocol_2eproto();

  void InitAsDefaultInstance();
  static RejectTopic* default_instance_;
};
// -------------------------------------------------------------------

class Subscribe : public ::google::protobuf::Message {
 public:
  Subscribe();
  virtual ~Subscribe();

  Subscribe(const Subscribe& from);

  inline Subscribe& operator=(const Subscribe& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Subscribe& default_instance();

  void Swap(Subscribe* other);

  // implements Message ----------------------------------------------

  Subscribe* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Subscribe& from);
  void MergeFrom(const Subscribe& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string Pattern = 1;
  inline bool has_pattern() const;
  inline void clear_pattern();
  static const int kPatternFieldNumber = 1;
  inline const ::std::string& pattern() const;
  inline void set_pattern(const ::std::string& value);
  inline void set_pattern(const char* value);
  inline void set_pattern(const char* value, size_t size);
  inline ::std::string* mutable_pattern();
  inline ::std::string* release_pattern();
  inline void set_allocated_pattern(::std::string* pattern);

  // optional string Topic = 2;
  inline bool has_topic() const;
  inline void clear_topic();
  static const int kTopicFieldNumber = 2;
  inline const ::std::string& topic() const;
  inline void set_topic(const ::std::string& value);
  inline void set_topic(const char* value);
  inline void set_topic(const char* value, size_t size);
  inline ::std::string* mutable_topic();
  inline ::std::string* release_topic();
  inline void set_allocated_topic(::std::string* topic);

  // optional string BackEndName = 3;
  inline bool has_backendname() const;
  inline void clear_backendname();
  static const int kBackEndNameFieldNumber = 3;
  inline const ::std::string& backendname() const;
  inline void set_backendname(const ::std::string& value);
  inline void set_backendname(const char* value);
  inline void set_backendname(const char* value, size_t size);
  inline ::std::string* mutable_backendname();
  inline ::std::string* release_backendname();
  inline void set_allocated_backendname(::std::string* backendname);

  // @@protoc_insertion_point(class_scope:NodesManager.Protocol.Subscribe)
 private:
  inline void set_has_pattern();
  inline void clear_has_pattern();
  inline void set_has_topic();
  inline void clear_has_topic();
  inline void set_has_backendname();
  inline void clear_has_backendname();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* pattern_;
  ::std::string* topic_;
  ::std::string* backendname_;
  friend void  protobuf_AddDesc_NodeManagerProtocol_2eproto();
  friend void protobuf_AssignDesc_NodeManagerProtocol_2eproto();
  friend void protobuf_ShutdownFile_NodeManagerProtocol_2eproto();

  void InitAsDefaultInstance();
  static Subscribe* default_instance_;
};
// -------------------------------------------------------------------

class UnSubscribe : public ::google::protobuf::Message {
 public:
  UnSubscribe();
  virtual ~UnSubscribe();

  UnSubscribe(const UnSubscribe& from);

  inline UnSubscribe& operator=(const UnSubscribe& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const UnSubscribe& default_instance();

  void Swap(UnSubscribe* other);

  // implements Message ----------------------------------------------

  UnSubscribe* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const UnSubscribe& from);
  void MergeFrom(const UnSubscribe& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string Pattern = 1;
  inline bool has_pattern() const;
  inline void clear_pattern();
  static const int kPatternFieldNumber = 1;
  inline const ::std::string& pattern() const;
  inline void set_pattern(const ::std::string& value);
  inline void set_pattern(const char* value);
  inline void set_pattern(const char* value, size_t size);
  inline ::std::string* mutable_pattern();
  inline ::std::string* release_pattern();
  inline void set_allocated_pattern(::std::string* pattern);

  // optional string Topic = 2;
  inline bool has_topic() const;
  inline void clear_topic();
  static const int kTopicFieldNumber = 2;
  inline const ::std::string& topic() const;
  inline void set_topic(const ::std::string& value);
  inline void set_topic(const char* value);
  inline void set_topic(const char* value, size_t size);
  inline ::std::string* mutable_topic();
  inline ::std::string* release_topic();
  inline void set_allocated_topic(::std::string* topic);

  // optional string BackEndName = 3;
  inline bool has_backendname() const;
  inline void clear_backendname();
  static const int kBackEndNameFieldNumber = 3;
  inline const ::std::string& backendname() const;
  inline void set_backendname(const ::std::string& value);
  inline void set_backendname(const char* value);
  inline void set_backendname(const char* value, size_t size);
  inline ::std::string* mutable_backendname();
  inline ::std::string* release_backendname();
  inline void set_allocated_backendname(::std::string* backendname);

  // @@protoc_insertion_point(class_scope:NodesManager.Protocol.UnSubscribe)
 private:
  inline void set_has_pattern();
  inline void clear_has_pattern();
  inline void set_has_topic();
  inline void clear_has_topic();
  inline void set_has_backendname();
  inline void clear_has_backendname();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* pattern_;
  ::std::string* topic_;
  ::std::string* backendname_;
  friend void  protobuf_AddDesc_NodeManagerProtocol_2eproto();
  friend void protobuf_AssignDesc_NodeManagerProtocol_2eproto();
  friend void protobuf_ShutdownFile_NodeManagerProtocol_2eproto();

  void InitAsDefaultInstance();
  static UnSubscribe* default_instance_;
};
// ===================================================================


// ===================================================================

// AdvertizeTopic

// optional string Pattern = 1;
inline bool AdvertizeTopic::has_pattern() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void AdvertizeTopic::set_has_pattern() {
  _has_bits_[0] |= 0x00000001u;
}
inline void AdvertizeTopic::clear_has_pattern() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void AdvertizeTopic::clear_pattern() {
  if (pattern_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    pattern_->clear();
  }
  clear_has_pattern();
}
inline const ::std::string& AdvertizeTopic::pattern() const {
  // @@protoc_insertion_point(field_get:NodesManager.Protocol.AdvertizeTopic.Pattern)
  return *pattern_;
}
inline void AdvertizeTopic::set_pattern(const ::std::string& value) {
  set_has_pattern();
  if (pattern_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    pattern_ = new ::std::string;
  }
  pattern_->assign(value);
  // @@protoc_insertion_point(field_set:NodesManager.Protocol.AdvertizeTopic.Pattern)
}
inline void AdvertizeTopic::set_pattern(const char* value) {
  set_has_pattern();
  if (pattern_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    pattern_ = new ::std::string;
  }
  pattern_->assign(value);
  // @@protoc_insertion_point(field_set_char:NodesManager.Protocol.AdvertizeTopic.Pattern)
}
inline void AdvertizeTopic::set_pattern(const char* value, size_t size) {
  set_has_pattern();
  if (pattern_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    pattern_ = new ::std::string;
  }
  pattern_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:NodesManager.Protocol.AdvertizeTopic.Pattern)
}
inline ::std::string* AdvertizeTopic::mutable_pattern() {
  set_has_pattern();
  if (pattern_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    pattern_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:NodesManager.Protocol.AdvertizeTopic.Pattern)
  return pattern_;
}
inline ::std::string* AdvertizeTopic::release_pattern() {
  clear_has_pattern();
  if (pattern_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = pattern_;
    pattern_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void AdvertizeTopic::set_allocated_pattern(::std::string* pattern) {
  if (pattern_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete pattern_;
  }
  if (pattern) {
    set_has_pattern();
    pattern_ = pattern;
  } else {
    clear_has_pattern();
    pattern_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:NodesManager.Protocol.AdvertizeTopic.Pattern)
}

// optional string Topic = 2;
inline bool AdvertizeTopic::has_topic() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void AdvertizeTopic::set_has_topic() {
  _has_bits_[0] |= 0x00000002u;
}
inline void AdvertizeTopic::clear_has_topic() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void AdvertizeTopic::clear_topic() {
  if (topic_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    topic_->clear();
  }
  clear_has_topic();
}
inline const ::std::string& AdvertizeTopic::topic() const {
  // @@protoc_insertion_point(field_get:NodesManager.Protocol.AdvertizeTopic.Topic)
  return *topic_;
}
inline void AdvertizeTopic::set_topic(const ::std::string& value) {
  set_has_topic();
  if (topic_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    topic_ = new ::std::string;
  }
  topic_->assign(value);
  // @@protoc_insertion_point(field_set:NodesManager.Protocol.AdvertizeTopic.Topic)
}
inline void AdvertizeTopic::set_topic(const char* value) {
  set_has_topic();
  if (topic_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    topic_ = new ::std::string;
  }
  topic_->assign(value);
  // @@protoc_insertion_point(field_set_char:NodesManager.Protocol.AdvertizeTopic.Topic)
}
inline void AdvertizeTopic::set_topic(const char* value, size_t size) {
  set_has_topic();
  if (topic_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    topic_ = new ::std::string;
  }
  topic_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:NodesManager.Protocol.AdvertizeTopic.Topic)
}
inline ::std::string* AdvertizeTopic::mutable_topic() {
  set_has_topic();
  if (topic_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    topic_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:NodesManager.Protocol.AdvertizeTopic.Topic)
  return topic_;
}
inline ::std::string* AdvertizeTopic::release_topic() {
  clear_has_topic();
  if (topic_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = topic_;
    topic_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void AdvertizeTopic::set_allocated_topic(::std::string* topic) {
  if (topic_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete topic_;
  }
  if (topic) {
    set_has_topic();
    topic_ = topic;
  } else {
    clear_has_topic();
    topic_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:NodesManager.Protocol.AdvertizeTopic.Topic)
}

// optional string BackEndName = 4;
inline bool AdvertizeTopic::has_backendname() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void AdvertizeTopic::set_has_backendname() {
  _has_bits_[0] |= 0x00000004u;
}
inline void AdvertizeTopic::clear_has_backendname() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void AdvertizeTopic::clear_backendname() {
  if (backendname_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    backendname_->clear();
  }
  clear_has_backendname();
}
inline const ::std::string& AdvertizeTopic::backendname() const {
  // @@protoc_insertion_point(field_get:NodesManager.Protocol.AdvertizeTopic.BackEndName)
  return *backendname_;
}
inline void AdvertizeTopic::set_backendname(const ::std::string& value) {
  set_has_backendname();
  if (backendname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    backendname_ = new ::std::string;
  }
  backendname_->assign(value);
  // @@protoc_insertion_point(field_set:NodesManager.Protocol.AdvertizeTopic.BackEndName)
}
inline void AdvertizeTopic::set_backendname(const char* value) {
  set_has_backendname();
  if (backendname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    backendname_ = new ::std::string;
  }
  backendname_->assign(value);
  // @@protoc_insertion_point(field_set_char:NodesManager.Protocol.AdvertizeTopic.BackEndName)
}
inline void AdvertizeTopic::set_backendname(const char* value, size_t size) {
  set_has_backendname();
  if (backendname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    backendname_ = new ::std::string;
  }
  backendname_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:NodesManager.Protocol.AdvertizeTopic.BackEndName)
}
inline ::std::string* AdvertizeTopic::mutable_backendname() {
  set_has_backendname();
  if (backendname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    backendname_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:NodesManager.Protocol.AdvertizeTopic.BackEndName)
  return backendname_;
}
inline ::std::string* AdvertizeTopic::release_backendname() {
  clear_has_backendname();
  if (backendname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = backendname_;
    backendname_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void AdvertizeTopic::set_allocated_backendname(::std::string* backendname) {
  if (backendname_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete backendname_;
  }
  if (backendname) {
    set_has_backendname();
    backendname_ = backendname;
  } else {
    clear_has_backendname();
    backendname_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:NodesManager.Protocol.AdvertizeTopic.BackEndName)
}

// -------------------------------------------------------------------

// ConnectRequest

// optional string NodeName = 1;
inline bool ConnectRequest::has_nodename() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ConnectRequest::set_has_nodename() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ConnectRequest::clear_has_nodename() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ConnectRequest::clear_nodename() {
  if (nodename_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    nodename_->clear();
  }
  clear_has_nodename();
}
inline const ::std::string& ConnectRequest::nodename() const {
  // @@protoc_insertion_point(field_get:NodesManager.Protocol.ConnectRequest.NodeName)
  return *nodename_;
}
inline void ConnectRequest::set_nodename(const ::std::string& value) {
  set_has_nodename();
  if (nodename_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    nodename_ = new ::std::string;
  }
  nodename_->assign(value);
  // @@protoc_insertion_point(field_set:NodesManager.Protocol.ConnectRequest.NodeName)
}
inline void ConnectRequest::set_nodename(const char* value) {
  set_has_nodename();
  if (nodename_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    nodename_ = new ::std::string;
  }
  nodename_->assign(value);
  // @@protoc_insertion_point(field_set_char:NodesManager.Protocol.ConnectRequest.NodeName)
}
inline void ConnectRequest::set_nodename(const char* value, size_t size) {
  set_has_nodename();
  if (nodename_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    nodename_ = new ::std::string;
  }
  nodename_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:NodesManager.Protocol.ConnectRequest.NodeName)
}
inline ::std::string* ConnectRequest::mutable_nodename() {
  set_has_nodename();
  if (nodename_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    nodename_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:NodesManager.Protocol.ConnectRequest.NodeName)
  return nodename_;
}
inline ::std::string* ConnectRequest::release_nodename() {
  clear_has_nodename();
  if (nodename_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = nodename_;
    nodename_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void ConnectRequest::set_allocated_nodename(::std::string* nodename) {
  if (nodename_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete nodename_;
  }
  if (nodename) {
    set_has_nodename();
    nodename_ = nodename;
  } else {
    clear_has_nodename();
    nodename_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:NodesManager.Protocol.ConnectRequest.NodeName)
}

// -------------------------------------------------------------------

// ConnectResponse

// optional string RealNodeName = 1;
inline bool ConnectResponse::has_realnodename() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ConnectResponse::set_has_realnodename() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ConnectResponse::clear_has_realnodename() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ConnectResponse::clear_realnodename() {
  if (realnodename_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    realnodename_->clear();
  }
  clear_has_realnodename();
}
inline const ::std::string& ConnectResponse::realnodename() const {
  // @@protoc_insertion_point(field_get:NodesManager.Protocol.ConnectResponse.RealNodeName)
  return *realnodename_;
}
inline void ConnectResponse::set_realnodename(const ::std::string& value) {
  set_has_realnodename();
  if (realnodename_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    realnodename_ = new ::std::string;
  }
  realnodename_->assign(value);
  // @@protoc_insertion_point(field_set:NodesManager.Protocol.ConnectResponse.RealNodeName)
}
inline void ConnectResponse::set_realnodename(const char* value) {
  set_has_realnodename();
  if (realnodename_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    realnodename_ = new ::std::string;
  }
  realnodename_->assign(value);
  // @@protoc_insertion_point(field_set_char:NodesManager.Protocol.ConnectResponse.RealNodeName)
}
inline void ConnectResponse::set_realnodename(const char* value, size_t size) {
  set_has_realnodename();
  if (realnodename_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    realnodename_ = new ::std::string;
  }
  realnodename_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:NodesManager.Protocol.ConnectResponse.RealNodeName)
}
inline ::std::string* ConnectResponse::mutable_realnodename() {
  set_has_realnodename();
  if (realnodename_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    realnodename_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:NodesManager.Protocol.ConnectResponse.RealNodeName)
  return realnodename_;
}
inline ::std::string* ConnectResponse::release_realnodename() {
  clear_has_realnodename();
  if (realnodename_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = realnodename_;
    realnodename_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void ConnectResponse::set_allocated_realnodename(::std::string* realnodename) {
  if (realnodename_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete realnodename_;
  }
  if (realnodename) {
    set_has_realnodename();
    realnodename_ = realnodename;
  } else {
    clear_has_realnodename();
    realnodename_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:NodesManager.Protocol.ConnectResponse.RealNodeName)
}

// optional int32 HeartBeatRateMs = 2 [default = 0];
inline bool ConnectResponse::has_heartbeatratems() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ConnectResponse::set_has_heartbeatratems() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ConnectResponse::clear_has_heartbeatratems() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ConnectResponse::clear_heartbeatratems() {
  heartbeatratems_ = 0;
  clear_has_heartbeatratems();
}
inline ::google::protobuf::int32 ConnectResponse::heartbeatratems() const {
  // @@protoc_insertion_point(field_get:NodesManager.Protocol.ConnectResponse.HeartBeatRateMs)
  return heartbeatratems_;
}
inline void ConnectResponse::set_heartbeatratems(::google::protobuf::int32 value) {
  set_has_heartbeatratems();
  heartbeatratems_ = value;
  // @@protoc_insertion_point(field_set:NodesManager.Protocol.ConnectResponse.HeartBeatRateMs)
}

// -------------------------------------------------------------------

// Disconnect

// -------------------------------------------------------------------

// GetAllPublishersRequest

// optional int32 RequestId = 1 [default = 0];
inline bool GetAllPublishersRequest::has_requestid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GetAllPublishersRequest::set_has_requestid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GetAllPublishersRequest::clear_has_requestid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GetAllPublishersRequest::clear_requestid() {
  requestid_ = 0;
  clear_has_requestid();
}
inline ::google::protobuf::int32 GetAllPublishersRequest::requestid() const {
  // @@protoc_insertion_point(field_get:NodesManager.Protocol.GetAllPublishersRequest.RequestId)
  return requestid_;
}
inline void GetAllPublishersRequest::set_requestid(::google::protobuf::int32 value) {
  set_has_requestid();
  requestid_ = value;
  // @@protoc_insertion_point(field_set:NodesManager.Protocol.GetAllPublishersRequest.RequestId)
}

// optional string Pattern = 2;
inline bool GetAllPublishersRequest::has_pattern() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GetAllPublishersRequest::set_has_pattern() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GetAllPublishersRequest::clear_has_pattern() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GetAllPublishersRequest::clear_pattern() {
  if (pattern_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    pattern_->clear();
  }
  clear_has_pattern();
}
inline const ::std::string& GetAllPublishersRequest::pattern() const {
  // @@protoc_insertion_point(field_get:NodesManager.Protocol.GetAllPublishersRequest.Pattern)
  return *pattern_;
}
inline void GetAllPublishersRequest::set_pattern(const ::std::string& value) {
  set_has_pattern();
  if (pattern_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    pattern_ = new ::std::string;
  }
  pattern_->assign(value);
  // @@protoc_insertion_point(field_set:NodesManager.Protocol.GetAllPublishersRequest.Pattern)
}
inline void GetAllPublishersRequest::set_pattern(const char* value) {
  set_has_pattern();
  if (pattern_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    pattern_ = new ::std::string;
  }
  pattern_->assign(value);
  // @@protoc_insertion_point(field_set_char:NodesManager.Protocol.GetAllPublishersRequest.Pattern)
}
inline void GetAllPublishersRequest::set_pattern(const char* value, size_t size) {
  set_has_pattern();
  if (pattern_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    pattern_ = new ::std::string;
  }
  pattern_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:NodesManager.Protocol.GetAllPublishersRequest.Pattern)
}
inline ::std::string* GetAllPublishersRequest::mutable_pattern() {
  set_has_pattern();
  if (pattern_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    pattern_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:NodesManager.Protocol.GetAllPublishersRequest.Pattern)
  return pattern_;
}
inline ::std::string* GetAllPublishersRequest::release_pattern() {
  clear_has_pattern();
  if (pattern_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = pattern_;
    pattern_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void GetAllPublishersRequest::set_allocated_pattern(::std::string* pattern) {
  if (pattern_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete pattern_;
  }
  if (pattern) {
    set_has_pattern();
    pattern_ = pattern;
  } else {
    clear_has_pattern();
    pattern_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:NodesManager.Protocol.GetAllPublishersRequest.Pattern)
}

// optional string BackEndName = 3;
inline bool GetAllPublishersRequest::has_backendname() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void GetAllPublishersRequest::set_has_backendname() {
  _has_bits_[0] |= 0x00000004u;
}
inline void GetAllPublishersRequest::clear_has_backendname() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void GetAllPublishersRequest::clear_backendname() {
  if (backendname_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    backendname_->clear();
  }
  clear_has_backendname();
}
inline const ::std::string& GetAllPublishersRequest::backendname() const {
  // @@protoc_insertion_point(field_get:NodesManager.Protocol.GetAllPublishersRequest.BackEndName)
  return *backendname_;
}
inline void GetAllPublishersRequest::set_backendname(const ::std::string& value) {
  set_has_backendname();
  if (backendname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    backendname_ = new ::std::string;
  }
  backendname_->assign(value);
  // @@protoc_insertion_point(field_set:NodesManager.Protocol.GetAllPublishersRequest.BackEndName)
}
inline void GetAllPublishersRequest::set_backendname(const char* value) {
  set_has_backendname();
  if (backendname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    backendname_ = new ::std::string;
  }
  backendname_->assign(value);
  // @@protoc_insertion_point(field_set_char:NodesManager.Protocol.GetAllPublishersRequest.BackEndName)
}
inline void GetAllPublishersRequest::set_backendname(const char* value, size_t size) {
  set_has_backendname();
  if (backendname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    backendname_ = new ::std::string;
  }
  backendname_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:NodesManager.Protocol.GetAllPublishersRequest.BackEndName)
}
inline ::std::string* GetAllPublishersRequest::mutable_backendname() {
  set_has_backendname();
  if (backendname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    backendname_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:NodesManager.Protocol.GetAllPublishersRequest.BackEndName)
  return backendname_;
}
inline ::std::string* GetAllPublishersRequest::release_backendname() {
  clear_has_backendname();
  if (backendname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = backendname_;
    backendname_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void GetAllPublishersRequest::set_allocated_backendname(::std::string* backendname) {
  if (backendname_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete backendname_;
  }
  if (backendname) {
    set_has_backendname();
    backendname_ = backendname;
  } else {
    clear_has_backendname();
    backendname_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:NodesManager.Protocol.GetAllPublishersRequest.BackEndName)
}

// optional string Topic = 4;
inline bool GetAllPublishersRequest::has_topic() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void GetAllPublishersRequest::set_has_topic() {
  _has_bits_[0] |= 0x00000008u;
}
inline void GetAllPublishersRequest::clear_has_topic() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void GetAllPublishersRequest::clear_topic() {
  if (topic_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    topic_->clear();
  }
  clear_has_topic();
}
inline const ::std::string& GetAllPublishersRequest::topic() const {
  // @@protoc_insertion_point(field_get:NodesManager.Protocol.GetAllPublishersRequest.Topic)
  return *topic_;
}
inline void GetAllPublishersRequest::set_topic(const ::std::string& value) {
  set_has_topic();
  if (topic_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    topic_ = new ::std::string;
  }
  topic_->assign(value);
  // @@protoc_insertion_point(field_set:NodesManager.Protocol.GetAllPublishersRequest.Topic)
}
inline void GetAllPublishersRequest::set_topic(const char* value) {
  set_has_topic();
  if (topic_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    topic_ = new ::std::string;
  }
  topic_->assign(value);
  // @@protoc_insertion_point(field_set_char:NodesManager.Protocol.GetAllPublishersRequest.Topic)
}
inline void GetAllPublishersRequest::set_topic(const char* value, size_t size) {
  set_has_topic();
  if (topic_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    topic_ = new ::std::string;
  }
  topic_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:NodesManager.Protocol.GetAllPublishersRequest.Topic)
}
inline ::std::string* GetAllPublishersRequest::mutable_topic() {
  set_has_topic();
  if (topic_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    topic_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:NodesManager.Protocol.GetAllPublishersRequest.Topic)
  return topic_;
}
inline ::std::string* GetAllPublishersRequest::release_topic() {
  clear_has_topic();
  if (topic_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = topic_;
    topic_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void GetAllPublishersRequest::set_allocated_topic(::std::string* topic) {
  if (topic_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete topic_;
  }
  if (topic) {
    set_has_topic();
    topic_ = topic;
  } else {
    clear_has_topic();
    topic_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:NodesManager.Protocol.GetAllPublishersRequest.Topic)
}

// -------------------------------------------------------------------

// GetAllPublishersResponse

// optional int32 RequestId = 1 [default = 0];
inline bool GetAllPublishersResponse::has_requestid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GetAllPublishersResponse::set_has_requestid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GetAllPublishersResponse::clear_has_requestid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GetAllPublishersResponse::clear_requestid() {
  requestid_ = 0;
  clear_has_requestid();
}
inline ::google::protobuf::int32 GetAllPublishersResponse::requestid() const {
  // @@protoc_insertion_point(field_get:NodesManager.Protocol.GetAllPublishersResponse.RequestId)
  return requestid_;
}
inline void GetAllPublishersResponse::set_requestid(::google::protobuf::int32 value) {
  set_has_requestid();
  requestid_ = value;
  // @@protoc_insertion_point(field_set:NodesManager.Protocol.GetAllPublishersResponse.RequestId)
}

// repeated string Nodes = 2;
inline int GetAllPublishersResponse::nodes_size() const {
  return nodes_.size();
}
inline void GetAllPublishersResponse::clear_nodes() {
  nodes_.Clear();
}
inline const ::std::string& GetAllPublishersResponse::nodes(int index) const {
  // @@protoc_insertion_point(field_get:NodesManager.Protocol.GetAllPublishersResponse.Nodes)
  return nodes_.Get(index);
}
inline ::std::string* GetAllPublishersResponse::mutable_nodes(int index) {
  // @@protoc_insertion_point(field_mutable:NodesManager.Protocol.GetAllPublishersResponse.Nodes)
  return nodes_.Mutable(index);
}
inline void GetAllPublishersResponse::set_nodes(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:NodesManager.Protocol.GetAllPublishersResponse.Nodes)
  nodes_.Mutable(index)->assign(value);
}
inline void GetAllPublishersResponse::set_nodes(int index, const char* value) {
  nodes_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:NodesManager.Protocol.GetAllPublishersResponse.Nodes)
}
inline void GetAllPublishersResponse::set_nodes(int index, const char* value, size_t size) {
  nodes_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:NodesManager.Protocol.GetAllPublishersResponse.Nodes)
}
inline ::std::string* GetAllPublishersResponse::add_nodes() {
  return nodes_.Add();
}
inline void GetAllPublishersResponse::add_nodes(const ::std::string& value) {
  nodes_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:NodesManager.Protocol.GetAllPublishersResponse.Nodes)
}
inline void GetAllPublishersResponse::add_nodes(const char* value) {
  nodes_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:NodesManager.Protocol.GetAllPublishersResponse.Nodes)
}
inline void GetAllPublishersResponse::add_nodes(const char* value, size_t size) {
  nodes_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:NodesManager.Protocol.GetAllPublishersResponse.Nodes)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
GetAllPublishersResponse::nodes() const {
  // @@protoc_insertion_point(field_list:NodesManager.Protocol.GetAllPublishersResponse.Nodes)
  return nodes_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
GetAllPublishersResponse::mutable_nodes() {
  // @@protoc_insertion_point(field_mutable_list:NodesManager.Protocol.GetAllPublishersResponse.Nodes)
  return &nodes_;
}

// -------------------------------------------------------------------

// GetAllSubscribersRequest

// optional int32 RequestId = 1 [default = 0];
inline bool GetAllSubscribersRequest::has_requestid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GetAllSubscribersRequest::set_has_requestid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GetAllSubscribersRequest::clear_has_requestid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GetAllSubscribersRequest::clear_requestid() {
  requestid_ = 0;
  clear_has_requestid();
}
inline ::google::protobuf::int32 GetAllSubscribersRequest::requestid() const {
  // @@protoc_insertion_point(field_get:NodesManager.Protocol.GetAllSubscribersRequest.RequestId)
  return requestid_;
}
inline void GetAllSubscribersRequest::set_requestid(::google::protobuf::int32 value) {
  set_has_requestid();
  requestid_ = value;
  // @@protoc_insertion_point(field_set:NodesManager.Protocol.GetAllSubscribersRequest.RequestId)
}

// optional string Pattern = 2;
inline bool GetAllSubscribersRequest::has_pattern() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GetAllSubscribersRequest::set_has_pattern() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GetAllSubscribersRequest::clear_has_pattern() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GetAllSubscribersRequest::clear_pattern() {
  if (pattern_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    pattern_->clear();
  }
  clear_has_pattern();
}
inline const ::std::string& GetAllSubscribersRequest::pattern() const {
  // @@protoc_insertion_point(field_get:NodesManager.Protocol.GetAllSubscribersRequest.Pattern)
  return *pattern_;
}
inline void GetAllSubscribersRequest::set_pattern(const ::std::string& value) {
  set_has_pattern();
  if (pattern_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    pattern_ = new ::std::string;
  }
  pattern_->assign(value);
  // @@protoc_insertion_point(field_set:NodesManager.Protocol.GetAllSubscribersRequest.Pattern)
}
inline void GetAllSubscribersRequest::set_pattern(const char* value) {
  set_has_pattern();
  if (pattern_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    pattern_ = new ::std::string;
  }
  pattern_->assign(value);
  // @@protoc_insertion_point(field_set_char:NodesManager.Protocol.GetAllSubscribersRequest.Pattern)
}
inline void GetAllSubscribersRequest::set_pattern(const char* value, size_t size) {
  set_has_pattern();
  if (pattern_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    pattern_ = new ::std::string;
  }
  pattern_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:NodesManager.Protocol.GetAllSubscribersRequest.Pattern)
}
inline ::std::string* GetAllSubscribersRequest::mutable_pattern() {
  set_has_pattern();
  if (pattern_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    pattern_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:NodesManager.Protocol.GetAllSubscribersRequest.Pattern)
  return pattern_;
}
inline ::std::string* GetAllSubscribersRequest::release_pattern() {
  clear_has_pattern();
  if (pattern_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = pattern_;
    pattern_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void GetAllSubscribersRequest::set_allocated_pattern(::std::string* pattern) {
  if (pattern_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete pattern_;
  }
  if (pattern) {
    set_has_pattern();
    pattern_ = pattern;
  } else {
    clear_has_pattern();
    pattern_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:NodesManager.Protocol.GetAllSubscribersRequest.Pattern)
}

// optional string BackEndName = 3;
inline bool GetAllSubscribersRequest::has_backendname() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void GetAllSubscribersRequest::set_has_backendname() {
  _has_bits_[0] |= 0x00000004u;
}
inline void GetAllSubscribersRequest::clear_has_backendname() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void GetAllSubscribersRequest::clear_backendname() {
  if (backendname_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    backendname_->clear();
  }
  clear_has_backendname();
}
inline const ::std::string& GetAllSubscribersRequest::backendname() const {
  // @@protoc_insertion_point(field_get:NodesManager.Protocol.GetAllSubscribersRequest.BackEndName)
  return *backendname_;
}
inline void GetAllSubscribersRequest::set_backendname(const ::std::string& value) {
  set_has_backendname();
  if (backendname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    backendname_ = new ::std::string;
  }
  backendname_->assign(value);
  // @@protoc_insertion_point(field_set:NodesManager.Protocol.GetAllSubscribersRequest.BackEndName)
}
inline void GetAllSubscribersRequest::set_backendname(const char* value) {
  set_has_backendname();
  if (backendname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    backendname_ = new ::std::string;
  }
  backendname_->assign(value);
  // @@protoc_insertion_point(field_set_char:NodesManager.Protocol.GetAllSubscribersRequest.BackEndName)
}
inline void GetAllSubscribersRequest::set_backendname(const char* value, size_t size) {
  set_has_backendname();
  if (backendname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    backendname_ = new ::std::string;
  }
  backendname_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:NodesManager.Protocol.GetAllSubscribersRequest.BackEndName)
}
inline ::std::string* GetAllSubscribersRequest::mutable_backendname() {
  set_has_backendname();
  if (backendname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    backendname_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:NodesManager.Protocol.GetAllSubscribersRequest.BackEndName)
  return backendname_;
}
inline ::std::string* GetAllSubscribersRequest::release_backendname() {
  clear_has_backendname();
  if (backendname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = backendname_;
    backendname_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void GetAllSubscribersRequest::set_allocated_backendname(::std::string* backendname) {
  if (backendname_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete backendname_;
  }
  if (backendname) {
    set_has_backendname();
    backendname_ = backendname;
  } else {
    clear_has_backendname();
    backendname_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:NodesManager.Protocol.GetAllSubscribersRequest.BackEndName)
}

// optional string Topic = 4;
inline bool GetAllSubscribersRequest::has_topic() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void GetAllSubscribersRequest::set_has_topic() {
  _has_bits_[0] |= 0x00000008u;
}
inline void GetAllSubscribersRequest::clear_has_topic() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void GetAllSubscribersRequest::clear_topic() {
  if (topic_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    topic_->clear();
  }
  clear_has_topic();
}
inline const ::std::string& GetAllSubscribersRequest::topic() const {
  // @@protoc_insertion_point(field_get:NodesManager.Protocol.GetAllSubscribersRequest.Topic)
  return *topic_;
}
inline void GetAllSubscribersRequest::set_topic(const ::std::string& value) {
  set_has_topic();
  if (topic_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    topic_ = new ::std::string;
  }
  topic_->assign(value);
  // @@protoc_insertion_point(field_set:NodesManager.Protocol.GetAllSubscribersRequest.Topic)
}
inline void GetAllSubscribersRequest::set_topic(const char* value) {
  set_has_topic();
  if (topic_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    topic_ = new ::std::string;
  }
  topic_->assign(value);
  // @@protoc_insertion_point(field_set_char:NodesManager.Protocol.GetAllSubscribersRequest.Topic)
}
inline void GetAllSubscribersRequest::set_topic(const char* value, size_t size) {
  set_has_topic();
  if (topic_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    topic_ = new ::std::string;
  }
  topic_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:NodesManager.Protocol.GetAllSubscribersRequest.Topic)
}
inline ::std::string* GetAllSubscribersRequest::mutable_topic() {
  set_has_topic();
  if (topic_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    topic_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:NodesManager.Protocol.GetAllSubscribersRequest.Topic)
  return topic_;
}
inline ::std::string* GetAllSubscribersRequest::release_topic() {
  clear_has_topic();
  if (topic_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = topic_;
    topic_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void GetAllSubscribersRequest::set_allocated_topic(::std::string* topic) {
  if (topic_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete topic_;
  }
  if (topic) {
    set_has_topic();
    topic_ = topic;
  } else {
    clear_has_topic();
    topic_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:NodesManager.Protocol.GetAllSubscribersRequest.Topic)
}

// -------------------------------------------------------------------

// GetAllSubscribersResponse

// optional int32 RequestId = 1 [default = 0];
inline bool GetAllSubscribersResponse::has_requestid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GetAllSubscribersResponse::set_has_requestid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GetAllSubscribersResponse::clear_has_requestid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GetAllSubscribersResponse::clear_requestid() {
  requestid_ = 0;
  clear_has_requestid();
}
inline ::google::protobuf::int32 GetAllSubscribersResponse::requestid() const {
  // @@protoc_insertion_point(field_get:NodesManager.Protocol.GetAllSubscribersResponse.RequestId)
  return requestid_;
}
inline void GetAllSubscribersResponse::set_requestid(::google::protobuf::int32 value) {
  set_has_requestid();
  requestid_ = value;
  // @@protoc_insertion_point(field_set:NodesManager.Protocol.GetAllSubscribersResponse.RequestId)
}

// repeated string Nodes = 2;
inline int GetAllSubscribersResponse::nodes_size() const {
  return nodes_.size();
}
inline void GetAllSubscribersResponse::clear_nodes() {
  nodes_.Clear();
}
inline const ::std::string& GetAllSubscribersResponse::nodes(int index) const {
  // @@protoc_insertion_point(field_get:NodesManager.Protocol.GetAllSubscribersResponse.Nodes)
  return nodes_.Get(index);
}
inline ::std::string* GetAllSubscribersResponse::mutable_nodes(int index) {
  // @@protoc_insertion_point(field_mutable:NodesManager.Protocol.GetAllSubscribersResponse.Nodes)
  return nodes_.Mutable(index);
}
inline void GetAllSubscribersResponse::set_nodes(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:NodesManager.Protocol.GetAllSubscribersResponse.Nodes)
  nodes_.Mutable(index)->assign(value);
}
inline void GetAllSubscribersResponse::set_nodes(int index, const char* value) {
  nodes_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:NodesManager.Protocol.GetAllSubscribersResponse.Nodes)
}
inline void GetAllSubscribersResponse::set_nodes(int index, const char* value, size_t size) {
  nodes_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:NodesManager.Protocol.GetAllSubscribersResponse.Nodes)
}
inline ::std::string* GetAllSubscribersResponse::add_nodes() {
  return nodes_.Add();
}
inline void GetAllSubscribersResponse::add_nodes(const ::std::string& value) {
  nodes_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:NodesManager.Protocol.GetAllSubscribersResponse.Nodes)
}
inline void GetAllSubscribersResponse::add_nodes(const char* value) {
  nodes_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:NodesManager.Protocol.GetAllSubscribersResponse.Nodes)
}
inline void GetAllSubscribersResponse::add_nodes(const char* value, size_t size) {
  nodes_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:NodesManager.Protocol.GetAllSubscribersResponse.Nodes)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
GetAllSubscribersResponse::nodes() const {
  // @@protoc_insertion_point(field_list:NodesManager.Protocol.GetAllSubscribersResponse.Nodes)
  return nodes_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
GetAllSubscribersResponse::mutable_nodes() {
  // @@protoc_insertion_point(field_mutable_list:NodesManager.Protocol.GetAllSubscribersResponse.Nodes)
  return &nodes_;
}

// -------------------------------------------------------------------

// GetPublisherRequest

// optional int32 RequestId = 1 [default = 0];
inline bool GetPublisherRequest::has_requestid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GetPublisherRequest::set_has_requestid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GetPublisherRequest::clear_has_requestid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GetPublisherRequest::clear_requestid() {
  requestid_ = 0;
  clear_has_requestid();
}
inline ::google::protobuf::int32 GetPublisherRequest::requestid() const {
  // @@protoc_insertion_point(field_get:NodesManager.Protocol.GetPublisherRequest.RequestId)
  return requestid_;
}
inline void GetPublisherRequest::set_requestid(::google::protobuf::int32 value) {
  set_has_requestid();
  requestid_ = value;
  // @@protoc_insertion_point(field_set:NodesManager.Protocol.GetPublisherRequest.RequestId)
}

// optional string Pattern = 2;
inline bool GetPublisherRequest::has_pattern() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GetPublisherRequest::set_has_pattern() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GetPublisherRequest::clear_has_pattern() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GetPublisherRequest::clear_pattern() {
  if (pattern_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    pattern_->clear();
  }
  clear_has_pattern();
}
inline const ::std::string& GetPublisherRequest::pattern() const {
  // @@protoc_insertion_point(field_get:NodesManager.Protocol.GetPublisherRequest.Pattern)
  return *pattern_;
}
inline void GetPublisherRequest::set_pattern(const ::std::string& value) {
  set_has_pattern();
  if (pattern_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    pattern_ = new ::std::string;
  }
  pattern_->assign(value);
  // @@protoc_insertion_point(field_set:NodesManager.Protocol.GetPublisherRequest.Pattern)
}
inline void GetPublisherRequest::set_pattern(const char* value) {
  set_has_pattern();
  if (pattern_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    pattern_ = new ::std::string;
  }
  pattern_->assign(value);
  // @@protoc_insertion_point(field_set_char:NodesManager.Protocol.GetPublisherRequest.Pattern)
}
inline void GetPublisherRequest::set_pattern(const char* value, size_t size) {
  set_has_pattern();
  if (pattern_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    pattern_ = new ::std::string;
  }
  pattern_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:NodesManager.Protocol.GetPublisherRequest.Pattern)
}
inline ::std::string* GetPublisherRequest::mutable_pattern() {
  set_has_pattern();
  if (pattern_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    pattern_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:NodesManager.Protocol.GetPublisherRequest.Pattern)
  return pattern_;
}
inline ::std::string* GetPublisherRequest::release_pattern() {
  clear_has_pattern();
  if (pattern_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = pattern_;
    pattern_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void GetPublisherRequest::set_allocated_pattern(::std::string* pattern) {
  if (pattern_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete pattern_;
  }
  if (pattern) {
    set_has_pattern();
    pattern_ = pattern;
  } else {
    clear_has_pattern();
    pattern_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:NodesManager.Protocol.GetPublisherRequest.Pattern)
}

// optional string BackEndName = 3;
inline bool GetPublisherRequest::has_backendname() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void GetPublisherRequest::set_has_backendname() {
  _has_bits_[0] |= 0x00000004u;
}
inline void GetPublisherRequest::clear_has_backendname() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void GetPublisherRequest::clear_backendname() {
  if (backendname_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    backendname_->clear();
  }
  clear_has_backendname();
}
inline const ::std::string& GetPublisherRequest::backendname() const {
  // @@protoc_insertion_point(field_get:NodesManager.Protocol.GetPublisherRequest.BackEndName)
  return *backendname_;
}
inline void GetPublisherRequest::set_backendname(const ::std::string& value) {
  set_has_backendname();
  if (backendname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    backendname_ = new ::std::string;
  }
  backendname_->assign(value);
  // @@protoc_insertion_point(field_set:NodesManager.Protocol.GetPublisherRequest.BackEndName)
}
inline void GetPublisherRequest::set_backendname(const char* value) {
  set_has_backendname();
  if (backendname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    backendname_ = new ::std::string;
  }
  backendname_->assign(value);
  // @@protoc_insertion_point(field_set_char:NodesManager.Protocol.GetPublisherRequest.BackEndName)
}
inline void GetPublisherRequest::set_backendname(const char* value, size_t size) {
  set_has_backendname();
  if (backendname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    backendname_ = new ::std::string;
  }
  backendname_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:NodesManager.Protocol.GetPublisherRequest.BackEndName)
}
inline ::std::string* GetPublisherRequest::mutable_backendname() {
  set_has_backendname();
  if (backendname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    backendname_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:NodesManager.Protocol.GetPublisherRequest.BackEndName)
  return backendname_;
}
inline ::std::string* GetPublisherRequest::release_backendname() {
  clear_has_backendname();
  if (backendname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = backendname_;
    backendname_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void GetPublisherRequest::set_allocated_backendname(::std::string* backendname) {
  if (backendname_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete backendname_;
  }
  if (backendname) {
    set_has_backendname();
    backendname_ = backendname;
  } else {
    clear_has_backendname();
    backendname_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:NodesManager.Protocol.GetPublisherRequest.BackEndName)
}

// optional string Topic = 4;
inline bool GetPublisherRequest::has_topic() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void GetPublisherRequest::set_has_topic() {
  _has_bits_[0] |= 0x00000008u;
}
inline void GetPublisherRequest::clear_has_topic() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void GetPublisherRequest::clear_topic() {
  if (topic_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    topic_->clear();
  }
  clear_has_topic();
}
inline const ::std::string& GetPublisherRequest::topic() const {
  // @@protoc_insertion_point(field_get:NodesManager.Protocol.GetPublisherRequest.Topic)
  return *topic_;
}
inline void GetPublisherRequest::set_topic(const ::std::string& value) {
  set_has_topic();
  if (topic_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    topic_ = new ::std::string;
  }
  topic_->assign(value);
  // @@protoc_insertion_point(field_set:NodesManager.Protocol.GetPublisherRequest.Topic)
}
inline void GetPublisherRequest::set_topic(const char* value) {
  set_has_topic();
  if (topic_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    topic_ = new ::std::string;
  }
  topic_->assign(value);
  // @@protoc_insertion_point(field_set_char:NodesManager.Protocol.GetPublisherRequest.Topic)
}
inline void GetPublisherRequest::set_topic(const char* value, size_t size) {
  set_has_topic();
  if (topic_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    topic_ = new ::std::string;
  }
  topic_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:NodesManager.Protocol.GetPublisherRequest.Topic)
}
inline ::std::string* GetPublisherRequest::mutable_topic() {
  set_has_topic();
  if (topic_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    topic_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:NodesManager.Protocol.GetPublisherRequest.Topic)
  return topic_;
}
inline ::std::string* GetPublisherRequest::release_topic() {
  clear_has_topic();
  if (topic_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = topic_;
    topic_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void GetPublisherRequest::set_allocated_topic(::std::string* topic) {
  if (topic_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete topic_;
  }
  if (topic) {
    set_has_topic();
    topic_ = topic;
  } else {
    clear_has_topic();
    topic_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:NodesManager.Protocol.GetPublisherRequest.Topic)
}

// -------------------------------------------------------------------

// GetPublishersResponse

// optional int32 RequestId = 1 [default = 0];
inline bool GetPublishersResponse::has_requestid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GetPublishersResponse::set_has_requestid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GetPublishersResponse::clear_has_requestid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GetPublishersResponse::clear_requestid() {
  requestid_ = 0;
  clear_has_requestid();
}
inline ::google::protobuf::int32 GetPublishersResponse::requestid() const {
  // @@protoc_insertion_point(field_get:NodesManager.Protocol.GetPublishersResponse.RequestId)
  return requestid_;
}
inline void GetPublishersResponse::set_requestid(::google::protobuf::int32 value) {
  set_has_requestid();
  requestid_ = value;
  // @@protoc_insertion_point(field_set:NodesManager.Protocol.GetPublishersResponse.RequestId)
}

// repeated string Nodes = 2;
inline int GetPublishersResponse::nodes_size() const {
  return nodes_.size();
}
inline void GetPublishersResponse::clear_nodes() {
  nodes_.Clear();
}
inline const ::std::string& GetPublishersResponse::nodes(int index) const {
  // @@protoc_insertion_point(field_get:NodesManager.Protocol.GetPublishersResponse.Nodes)
  return nodes_.Get(index);
}
inline ::std::string* GetPublishersResponse::mutable_nodes(int index) {
  // @@protoc_insertion_point(field_mutable:NodesManager.Protocol.GetPublishersResponse.Nodes)
  return nodes_.Mutable(index);
}
inline void GetPublishersResponse::set_nodes(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:NodesManager.Protocol.GetPublishersResponse.Nodes)
  nodes_.Mutable(index)->assign(value);
}
inline void GetPublishersResponse::set_nodes(int index, const char* value) {
  nodes_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:NodesManager.Protocol.GetPublishersResponse.Nodes)
}
inline void GetPublishersResponse::set_nodes(int index, const char* value, size_t size) {
  nodes_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:NodesManager.Protocol.GetPublishersResponse.Nodes)
}
inline ::std::string* GetPublishersResponse::add_nodes() {
  return nodes_.Add();
}
inline void GetPublishersResponse::add_nodes(const ::std::string& value) {
  nodes_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:NodesManager.Protocol.GetPublishersResponse.Nodes)
}
inline void GetPublishersResponse::add_nodes(const char* value) {
  nodes_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:NodesManager.Protocol.GetPublishersResponse.Nodes)
}
inline void GetPublishersResponse::add_nodes(const char* value, size_t size) {
  nodes_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:NodesManager.Protocol.GetPublishersResponse.Nodes)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
GetPublishersResponse::nodes() const {
  // @@protoc_insertion_point(field_list:NodesManager.Protocol.GetPublishersResponse.Nodes)
  return nodes_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
GetPublishersResponse::mutable_nodes() {
  // @@protoc_insertion_point(field_mutable_list:NodesManager.Protocol.GetPublishersResponse.Nodes)
  return &nodes_;
}

// -------------------------------------------------------------------

// GetSubscriberRequest

// optional int32 RequestId = 1 [default = 0];
inline bool GetSubscriberRequest::has_requestid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GetSubscriberRequest::set_has_requestid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GetSubscriberRequest::clear_has_requestid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GetSubscriberRequest::clear_requestid() {
  requestid_ = 0;
  clear_has_requestid();
}
inline ::google::protobuf::int32 GetSubscriberRequest::requestid() const {
  // @@protoc_insertion_point(field_get:NodesManager.Protocol.GetSubscriberRequest.RequestId)
  return requestid_;
}
inline void GetSubscriberRequest::set_requestid(::google::protobuf::int32 value) {
  set_has_requestid();
  requestid_ = value;
  // @@protoc_insertion_point(field_set:NodesManager.Protocol.GetSubscriberRequest.RequestId)
}

// optional string Pattern = 2;
inline bool GetSubscriberRequest::has_pattern() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GetSubscriberRequest::set_has_pattern() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GetSubscriberRequest::clear_has_pattern() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GetSubscriberRequest::clear_pattern() {
  if (pattern_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    pattern_->clear();
  }
  clear_has_pattern();
}
inline const ::std::string& GetSubscriberRequest::pattern() const {
  // @@protoc_insertion_point(field_get:NodesManager.Protocol.GetSubscriberRequest.Pattern)
  return *pattern_;
}
inline void GetSubscriberRequest::set_pattern(const ::std::string& value) {
  set_has_pattern();
  if (pattern_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    pattern_ = new ::std::string;
  }
  pattern_->assign(value);
  // @@protoc_insertion_point(field_set:NodesManager.Protocol.GetSubscriberRequest.Pattern)
}
inline void GetSubscriberRequest::set_pattern(const char* value) {
  set_has_pattern();
  if (pattern_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    pattern_ = new ::std::string;
  }
  pattern_->assign(value);
  // @@protoc_insertion_point(field_set_char:NodesManager.Protocol.GetSubscriberRequest.Pattern)
}
inline void GetSubscriberRequest::set_pattern(const char* value, size_t size) {
  set_has_pattern();
  if (pattern_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    pattern_ = new ::std::string;
  }
  pattern_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:NodesManager.Protocol.GetSubscriberRequest.Pattern)
}
inline ::std::string* GetSubscriberRequest::mutable_pattern() {
  set_has_pattern();
  if (pattern_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    pattern_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:NodesManager.Protocol.GetSubscriberRequest.Pattern)
  return pattern_;
}
inline ::std::string* GetSubscriberRequest::release_pattern() {
  clear_has_pattern();
  if (pattern_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = pattern_;
    pattern_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void GetSubscriberRequest::set_allocated_pattern(::std::string* pattern) {
  if (pattern_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete pattern_;
  }
  if (pattern) {
    set_has_pattern();
    pattern_ = pattern;
  } else {
    clear_has_pattern();
    pattern_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:NodesManager.Protocol.GetSubscriberRequest.Pattern)
}

// optional string BackEndName = 3;
inline bool GetSubscriberRequest::has_backendname() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void GetSubscriberRequest::set_has_backendname() {
  _has_bits_[0] |= 0x00000004u;
}
inline void GetSubscriberRequest::clear_has_backendname() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void GetSubscriberRequest::clear_backendname() {
  if (backendname_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    backendname_->clear();
  }
  clear_has_backendname();
}
inline const ::std::string& GetSubscriberRequest::backendname() const {
  // @@protoc_insertion_point(field_get:NodesManager.Protocol.GetSubscriberRequest.BackEndName)
  return *backendname_;
}
inline void GetSubscriberRequest::set_backendname(const ::std::string& value) {
  set_has_backendname();
  if (backendname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    backendname_ = new ::std::string;
  }
  backendname_->assign(value);
  // @@protoc_insertion_point(field_set:NodesManager.Protocol.GetSubscriberRequest.BackEndName)
}
inline void GetSubscriberRequest::set_backendname(const char* value) {
  set_has_backendname();
  if (backendname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    backendname_ = new ::std::string;
  }
  backendname_->assign(value);
  // @@protoc_insertion_point(field_set_char:NodesManager.Protocol.GetSubscriberRequest.BackEndName)
}
inline void GetSubscriberRequest::set_backendname(const char* value, size_t size) {
  set_has_backendname();
  if (backendname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    backendname_ = new ::std::string;
  }
  backendname_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:NodesManager.Protocol.GetSubscriberRequest.BackEndName)
}
inline ::std::string* GetSubscriberRequest::mutable_backendname() {
  set_has_backendname();
  if (backendname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    backendname_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:NodesManager.Protocol.GetSubscriberRequest.BackEndName)
  return backendname_;
}
inline ::std::string* GetSubscriberRequest::release_backendname() {
  clear_has_backendname();
  if (backendname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = backendname_;
    backendname_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void GetSubscriberRequest::set_allocated_backendname(::std::string* backendname) {
  if (backendname_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete backendname_;
  }
  if (backendname) {
    set_has_backendname();
    backendname_ = backendname;
  } else {
    clear_has_backendname();
    backendname_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:NodesManager.Protocol.GetSubscriberRequest.BackEndName)
}

// optional string Topic = 4;
inline bool GetSubscriberRequest::has_topic() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void GetSubscriberRequest::set_has_topic() {
  _has_bits_[0] |= 0x00000008u;
}
inline void GetSubscriberRequest::clear_has_topic() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void GetSubscriberRequest::clear_topic() {
  if (topic_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    topic_->clear();
  }
  clear_has_topic();
}
inline const ::std::string& GetSubscriberRequest::topic() const {
  // @@protoc_insertion_point(field_get:NodesManager.Protocol.GetSubscriberRequest.Topic)
  return *topic_;
}
inline void GetSubscriberRequest::set_topic(const ::std::string& value) {
  set_has_topic();
  if (topic_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    topic_ = new ::std::string;
  }
  topic_->assign(value);
  // @@protoc_insertion_point(field_set:NodesManager.Protocol.GetSubscriberRequest.Topic)
}
inline void GetSubscriberRequest::set_topic(const char* value) {
  set_has_topic();
  if (topic_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    topic_ = new ::std::string;
  }
  topic_->assign(value);
  // @@protoc_insertion_point(field_set_char:NodesManager.Protocol.GetSubscriberRequest.Topic)
}
inline void GetSubscriberRequest::set_topic(const char* value, size_t size) {
  set_has_topic();
  if (topic_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    topic_ = new ::std::string;
  }
  topic_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:NodesManager.Protocol.GetSubscriberRequest.Topic)
}
inline ::std::string* GetSubscriberRequest::mutable_topic() {
  set_has_topic();
  if (topic_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    topic_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:NodesManager.Protocol.GetSubscriberRequest.Topic)
  return topic_;
}
inline ::std::string* GetSubscriberRequest::release_topic() {
  clear_has_topic();
  if (topic_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = topic_;
    topic_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void GetSubscriberRequest::set_allocated_topic(::std::string* topic) {
  if (topic_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete topic_;
  }
  if (topic) {
    set_has_topic();
    topic_ = topic;
  } else {
    clear_has_topic();
    topic_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:NodesManager.Protocol.GetSubscriberRequest.Topic)
}

// -------------------------------------------------------------------

// GetSubscriberResponse

// optional int32 RequestId = 1 [default = 0];
inline bool GetSubscriberResponse::has_requestid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GetSubscriberResponse::set_has_requestid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GetSubscriberResponse::clear_has_requestid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GetSubscriberResponse::clear_requestid() {
  requestid_ = 0;
  clear_has_requestid();
}
inline ::google::protobuf::int32 GetSubscriberResponse::requestid() const {
  // @@protoc_insertion_point(field_get:NodesManager.Protocol.GetSubscriberResponse.RequestId)
  return requestid_;
}
inline void GetSubscriberResponse::set_requestid(::google::protobuf::int32 value) {
  set_has_requestid();
  requestid_ = value;
  // @@protoc_insertion_point(field_set:NodesManager.Protocol.GetSubscriberResponse.RequestId)
}

// optional string Node = 2;
inline bool GetSubscriberResponse::has_node() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GetSubscriberResponse::set_has_node() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GetSubscriberResponse::clear_has_node() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GetSubscriberResponse::clear_node() {
  if (node_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    node_->clear();
  }
  clear_has_node();
}
inline const ::std::string& GetSubscriberResponse::node() const {
  // @@protoc_insertion_point(field_get:NodesManager.Protocol.GetSubscriberResponse.Node)
  return *node_;
}
inline void GetSubscriberResponse::set_node(const ::std::string& value) {
  set_has_node();
  if (node_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    node_ = new ::std::string;
  }
  node_->assign(value);
  // @@protoc_insertion_point(field_set:NodesManager.Protocol.GetSubscriberResponse.Node)
}
inline void GetSubscriberResponse::set_node(const char* value) {
  set_has_node();
  if (node_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    node_ = new ::std::string;
  }
  node_->assign(value);
  // @@protoc_insertion_point(field_set_char:NodesManager.Protocol.GetSubscriberResponse.Node)
}
inline void GetSubscriberResponse::set_node(const char* value, size_t size) {
  set_has_node();
  if (node_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    node_ = new ::std::string;
  }
  node_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:NodesManager.Protocol.GetSubscriberResponse.Node)
}
inline ::std::string* GetSubscriberResponse::mutable_node() {
  set_has_node();
  if (node_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    node_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:NodesManager.Protocol.GetSubscriberResponse.Node)
  return node_;
}
inline ::std::string* GetSubscriberResponse::release_node() {
  clear_has_node();
  if (node_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = node_;
    node_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void GetSubscriberResponse::set_allocated_node(::std::string* node) {
  if (node_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete node_;
  }
  if (node) {
    set_has_node();
    node_ = node;
  } else {
    clear_has_node();
    node_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:NodesManager.Protocol.GetSubscriberResponse.Node)
}

// -------------------------------------------------------------------

// HeartBeat

// -------------------------------------------------------------------

// OnAdvertisedTopic

// optional string Node = 1;
inline bool OnAdvertisedTopic::has_node() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void OnAdvertisedTopic::set_has_node() {
  _has_bits_[0] |= 0x00000001u;
}
inline void OnAdvertisedTopic::clear_has_node() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void OnAdvertisedTopic::clear_node() {
  if (node_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    node_->clear();
  }
  clear_has_node();
}
inline const ::std::string& OnAdvertisedTopic::node() const {
  // @@protoc_insertion_point(field_get:NodesManager.Protocol.OnAdvertisedTopic.Node)
  return *node_;
}
inline void OnAdvertisedTopic::set_node(const ::std::string& value) {
  set_has_node();
  if (node_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    node_ = new ::std::string;
  }
  node_->assign(value);
  // @@protoc_insertion_point(field_set:NodesManager.Protocol.OnAdvertisedTopic.Node)
}
inline void OnAdvertisedTopic::set_node(const char* value) {
  set_has_node();
  if (node_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    node_ = new ::std::string;
  }
  node_->assign(value);
  // @@protoc_insertion_point(field_set_char:NodesManager.Protocol.OnAdvertisedTopic.Node)
}
inline void OnAdvertisedTopic::set_node(const char* value, size_t size) {
  set_has_node();
  if (node_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    node_ = new ::std::string;
  }
  node_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:NodesManager.Protocol.OnAdvertisedTopic.Node)
}
inline ::std::string* OnAdvertisedTopic::mutable_node() {
  set_has_node();
  if (node_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    node_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:NodesManager.Protocol.OnAdvertisedTopic.Node)
  return node_;
}
inline ::std::string* OnAdvertisedTopic::release_node() {
  clear_has_node();
  if (node_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = node_;
    node_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void OnAdvertisedTopic::set_allocated_node(::std::string* node) {
  if (node_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete node_;
  }
  if (node) {
    set_has_node();
    node_ = node;
  } else {
    clear_has_node();
    node_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:NodesManager.Protocol.OnAdvertisedTopic.Node)
}

// optional string Pattern = 2;
inline bool OnAdvertisedTopic::has_pattern() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void OnAdvertisedTopic::set_has_pattern() {
  _has_bits_[0] |= 0x00000002u;
}
inline void OnAdvertisedTopic::clear_has_pattern() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void OnAdvertisedTopic::clear_pattern() {
  if (pattern_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    pattern_->clear();
  }
  clear_has_pattern();
}
inline const ::std::string& OnAdvertisedTopic::pattern() const {
  // @@protoc_insertion_point(field_get:NodesManager.Protocol.OnAdvertisedTopic.Pattern)
  return *pattern_;
}
inline void OnAdvertisedTopic::set_pattern(const ::std::string& value) {
  set_has_pattern();
  if (pattern_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    pattern_ = new ::std::string;
  }
  pattern_->assign(value);
  // @@protoc_insertion_point(field_set:NodesManager.Protocol.OnAdvertisedTopic.Pattern)
}
inline void OnAdvertisedTopic::set_pattern(const char* value) {
  set_has_pattern();
  if (pattern_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    pattern_ = new ::std::string;
  }
  pattern_->assign(value);
  // @@protoc_insertion_point(field_set_char:NodesManager.Protocol.OnAdvertisedTopic.Pattern)
}
inline void OnAdvertisedTopic::set_pattern(const char* value, size_t size) {
  set_has_pattern();
  if (pattern_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    pattern_ = new ::std::string;
  }
  pattern_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:NodesManager.Protocol.OnAdvertisedTopic.Pattern)
}
inline ::std::string* OnAdvertisedTopic::mutable_pattern() {
  set_has_pattern();
  if (pattern_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    pattern_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:NodesManager.Protocol.OnAdvertisedTopic.Pattern)
  return pattern_;
}
inline ::std::string* OnAdvertisedTopic::release_pattern() {
  clear_has_pattern();
  if (pattern_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = pattern_;
    pattern_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void OnAdvertisedTopic::set_allocated_pattern(::std::string* pattern) {
  if (pattern_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete pattern_;
  }
  if (pattern) {
    set_has_pattern();
    pattern_ = pattern;
  } else {
    clear_has_pattern();
    pattern_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:NodesManager.Protocol.OnAdvertisedTopic.Pattern)
}

// optional string Topic = 3;
inline bool OnAdvertisedTopic::has_topic() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void OnAdvertisedTopic::set_has_topic() {
  _has_bits_[0] |= 0x00000004u;
}
inline void OnAdvertisedTopic::clear_has_topic() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void OnAdvertisedTopic::clear_topic() {
  if (topic_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    topic_->clear();
  }
  clear_has_topic();
}
inline const ::std::string& OnAdvertisedTopic::topic() const {
  // @@protoc_insertion_point(field_get:NodesManager.Protocol.OnAdvertisedTopic.Topic)
  return *topic_;
}
inline void OnAdvertisedTopic::set_topic(const ::std::string& value) {
  set_has_topic();
  if (topic_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    topic_ = new ::std::string;
  }
  topic_->assign(value);
  // @@protoc_insertion_point(field_set:NodesManager.Protocol.OnAdvertisedTopic.Topic)
}
inline void OnAdvertisedTopic::set_topic(const char* value) {
  set_has_topic();
  if (topic_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    topic_ = new ::std::string;
  }
  topic_->assign(value);
  // @@protoc_insertion_point(field_set_char:NodesManager.Protocol.OnAdvertisedTopic.Topic)
}
inline void OnAdvertisedTopic::set_topic(const char* value, size_t size) {
  set_has_topic();
  if (topic_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    topic_ = new ::std::string;
  }
  topic_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:NodesManager.Protocol.OnAdvertisedTopic.Topic)
}
inline ::std::string* OnAdvertisedTopic::mutable_topic() {
  set_has_topic();
  if (topic_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    topic_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:NodesManager.Protocol.OnAdvertisedTopic.Topic)
  return topic_;
}
inline ::std::string* OnAdvertisedTopic::release_topic() {
  clear_has_topic();
  if (topic_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = topic_;
    topic_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void OnAdvertisedTopic::set_allocated_topic(::std::string* topic) {
  if (topic_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete topic_;
  }
  if (topic) {
    set_has_topic();
    topic_ = topic;
  } else {
    clear_has_topic();
    topic_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:NodesManager.Protocol.OnAdvertisedTopic.Topic)
}

// optional string BackEndName = 4;
inline bool OnAdvertisedTopic::has_backendname() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void OnAdvertisedTopic::set_has_backendname() {
  _has_bits_[0] |= 0x00000008u;
}
inline void OnAdvertisedTopic::clear_has_backendname() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void OnAdvertisedTopic::clear_backendname() {
  if (backendname_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    backendname_->clear();
  }
  clear_has_backendname();
}
inline const ::std::string& OnAdvertisedTopic::backendname() const {
  // @@protoc_insertion_point(field_get:NodesManager.Protocol.OnAdvertisedTopic.BackEndName)
  return *backendname_;
}
inline void OnAdvertisedTopic::set_backendname(const ::std::string& value) {
  set_has_backendname();
  if (backendname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    backendname_ = new ::std::string;
  }
  backendname_->assign(value);
  // @@protoc_insertion_point(field_set:NodesManager.Protocol.OnAdvertisedTopic.BackEndName)
}
inline void OnAdvertisedTopic::set_backendname(const char* value) {
  set_has_backendname();
  if (backendname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    backendname_ = new ::std::string;
  }
  backendname_->assign(value);
  // @@protoc_insertion_point(field_set_char:NodesManager.Protocol.OnAdvertisedTopic.BackEndName)
}
inline void OnAdvertisedTopic::set_backendname(const char* value, size_t size) {
  set_has_backendname();
  if (backendname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    backendname_ = new ::std::string;
  }
  backendname_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:NodesManager.Protocol.OnAdvertisedTopic.BackEndName)
}
inline ::std::string* OnAdvertisedTopic::mutable_backendname() {
  set_has_backendname();
  if (backendname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    backendname_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:NodesManager.Protocol.OnAdvertisedTopic.BackEndName)
  return backendname_;
}
inline ::std::string* OnAdvertisedTopic::release_backendname() {
  clear_has_backendname();
  if (backendname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = backendname_;
    backendname_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void OnAdvertisedTopic::set_allocated_backendname(::std::string* backendname) {
  if (backendname_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete backendname_;
  }
  if (backendname) {
    set_has_backendname();
    backendname_ = backendname;
  } else {
    clear_has_backendname();
    backendname_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:NodesManager.Protocol.OnAdvertisedTopic.BackEndName)
}

// -------------------------------------------------------------------

// OnNodeRejectedTopic

// optional string Node = 1;
inline bool OnNodeRejectedTopic::has_node() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void OnNodeRejectedTopic::set_has_node() {
  _has_bits_[0] |= 0x00000001u;
}
inline void OnNodeRejectedTopic::clear_has_node() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void OnNodeRejectedTopic::clear_node() {
  if (node_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    node_->clear();
  }
  clear_has_node();
}
inline const ::std::string& OnNodeRejectedTopic::node() const {
  // @@protoc_insertion_point(field_get:NodesManager.Protocol.OnNodeRejectedTopic.Node)
  return *node_;
}
inline void OnNodeRejectedTopic::set_node(const ::std::string& value) {
  set_has_node();
  if (node_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    node_ = new ::std::string;
  }
  node_->assign(value);
  // @@protoc_insertion_point(field_set:NodesManager.Protocol.OnNodeRejectedTopic.Node)
}
inline void OnNodeRejectedTopic::set_node(const char* value) {
  set_has_node();
  if (node_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    node_ = new ::std::string;
  }
  node_->assign(value);
  // @@protoc_insertion_point(field_set_char:NodesManager.Protocol.OnNodeRejectedTopic.Node)
}
inline void OnNodeRejectedTopic::set_node(const char* value, size_t size) {
  set_has_node();
  if (node_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    node_ = new ::std::string;
  }
  node_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:NodesManager.Protocol.OnNodeRejectedTopic.Node)
}
inline ::std::string* OnNodeRejectedTopic::mutable_node() {
  set_has_node();
  if (node_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    node_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:NodesManager.Protocol.OnNodeRejectedTopic.Node)
  return node_;
}
inline ::std::string* OnNodeRejectedTopic::release_node() {
  clear_has_node();
  if (node_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = node_;
    node_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void OnNodeRejectedTopic::set_allocated_node(::std::string* node) {
  if (node_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete node_;
  }
  if (node) {
    set_has_node();
    node_ = node;
  } else {
    clear_has_node();
    node_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:NodesManager.Protocol.OnNodeRejectedTopic.Node)
}

// optional string Pattern = 2;
inline bool OnNodeRejectedTopic::has_pattern() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void OnNodeRejectedTopic::set_has_pattern() {
  _has_bits_[0] |= 0x00000002u;
}
inline void OnNodeRejectedTopic::clear_has_pattern() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void OnNodeRejectedTopic::clear_pattern() {
  if (pattern_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    pattern_->clear();
  }
  clear_has_pattern();
}
inline const ::std::string& OnNodeRejectedTopic::pattern() const {
  // @@protoc_insertion_point(field_get:NodesManager.Protocol.OnNodeRejectedTopic.Pattern)
  return *pattern_;
}
inline void OnNodeRejectedTopic::set_pattern(const ::std::string& value) {
  set_has_pattern();
  if (pattern_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    pattern_ = new ::std::string;
  }
  pattern_->assign(value);
  // @@protoc_insertion_point(field_set:NodesManager.Protocol.OnNodeRejectedTopic.Pattern)
}
inline void OnNodeRejectedTopic::set_pattern(const char* value) {
  set_has_pattern();
  if (pattern_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    pattern_ = new ::std::string;
  }
  pattern_->assign(value);
  // @@protoc_insertion_point(field_set_char:NodesManager.Protocol.OnNodeRejectedTopic.Pattern)
}
inline void OnNodeRejectedTopic::set_pattern(const char* value, size_t size) {
  set_has_pattern();
  if (pattern_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    pattern_ = new ::std::string;
  }
  pattern_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:NodesManager.Protocol.OnNodeRejectedTopic.Pattern)
}
inline ::std::string* OnNodeRejectedTopic::mutable_pattern() {
  set_has_pattern();
  if (pattern_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    pattern_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:NodesManager.Protocol.OnNodeRejectedTopic.Pattern)
  return pattern_;
}
inline ::std::string* OnNodeRejectedTopic::release_pattern() {
  clear_has_pattern();
  if (pattern_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = pattern_;
    pattern_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void OnNodeRejectedTopic::set_allocated_pattern(::std::string* pattern) {
  if (pattern_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete pattern_;
  }
  if (pattern) {
    set_has_pattern();
    pattern_ = pattern;
  } else {
    clear_has_pattern();
    pattern_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:NodesManager.Protocol.OnNodeRejectedTopic.Pattern)
}

// optional string Topic = 3;
inline bool OnNodeRejectedTopic::has_topic() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void OnNodeRejectedTopic::set_has_topic() {
  _has_bits_[0] |= 0x00000004u;
}
inline void OnNodeRejectedTopic::clear_has_topic() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void OnNodeRejectedTopic::clear_topic() {
  if (topic_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    topic_->clear();
  }
  clear_has_topic();
}
inline const ::std::string& OnNodeRejectedTopic::topic() const {
  // @@protoc_insertion_point(field_get:NodesManager.Protocol.OnNodeRejectedTopic.Topic)
  return *topic_;
}
inline void OnNodeRejectedTopic::set_topic(const ::std::string& value) {
  set_has_topic();
  if (topic_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    topic_ = new ::std::string;
  }
  topic_->assign(value);
  // @@protoc_insertion_point(field_set:NodesManager.Protocol.OnNodeRejectedTopic.Topic)
}
inline void OnNodeRejectedTopic::set_topic(const char* value) {
  set_has_topic();
  if (topic_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    topic_ = new ::std::string;
  }
  topic_->assign(value);
  // @@protoc_insertion_point(field_set_char:NodesManager.Protocol.OnNodeRejectedTopic.Topic)
}
inline void OnNodeRejectedTopic::set_topic(const char* value, size_t size) {
  set_has_topic();
  if (topic_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    topic_ = new ::std::string;
  }
  topic_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:NodesManager.Protocol.OnNodeRejectedTopic.Topic)
}
inline ::std::string* OnNodeRejectedTopic::mutable_topic() {
  set_has_topic();
  if (topic_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    topic_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:NodesManager.Protocol.OnNodeRejectedTopic.Topic)
  return topic_;
}
inline ::std::string* OnNodeRejectedTopic::release_topic() {
  clear_has_topic();
  if (topic_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = topic_;
    topic_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void OnNodeRejectedTopic::set_allocated_topic(::std::string* topic) {
  if (topic_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete topic_;
  }
  if (topic) {
    set_has_topic();
    topic_ = topic;
  } else {
    clear_has_topic();
    topic_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:NodesManager.Protocol.OnNodeRejectedTopic.Topic)
}

// optional string BackEndName = 4;
inline bool OnNodeRejectedTopic::has_backendname() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void OnNodeRejectedTopic::set_has_backendname() {
  _has_bits_[0] |= 0x00000008u;
}
inline void OnNodeRejectedTopic::clear_has_backendname() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void OnNodeRejectedTopic::clear_backendname() {
  if (backendname_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    backendname_->clear();
  }
  clear_has_backendname();
}
inline const ::std::string& OnNodeRejectedTopic::backendname() const {
  // @@protoc_insertion_point(field_get:NodesManager.Protocol.OnNodeRejectedTopic.BackEndName)
  return *backendname_;
}
inline void OnNodeRejectedTopic::set_backendname(const ::std::string& value) {
  set_has_backendname();
  if (backendname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    backendname_ = new ::std::string;
  }
  backendname_->assign(value);
  // @@protoc_insertion_point(field_set:NodesManager.Protocol.OnNodeRejectedTopic.BackEndName)
}
inline void OnNodeRejectedTopic::set_backendname(const char* value) {
  set_has_backendname();
  if (backendname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    backendname_ = new ::std::string;
  }
  backendname_->assign(value);
  // @@protoc_insertion_point(field_set_char:NodesManager.Protocol.OnNodeRejectedTopic.BackEndName)
}
inline void OnNodeRejectedTopic::set_backendname(const char* value, size_t size) {
  set_has_backendname();
  if (backendname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    backendname_ = new ::std::string;
  }
  backendname_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:NodesManager.Protocol.OnNodeRejectedTopic.BackEndName)
}
inline ::std::string* OnNodeRejectedTopic::mutable_backendname() {
  set_has_backendname();
  if (backendname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    backendname_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:NodesManager.Protocol.OnNodeRejectedTopic.BackEndName)
  return backendname_;
}
inline ::std::string* OnNodeRejectedTopic::release_backendname() {
  clear_has_backendname();
  if (backendname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = backendname_;
    backendname_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void OnNodeRejectedTopic::set_allocated_backendname(::std::string* backendname) {
  if (backendname_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete backendname_;
  }
  if (backendname) {
    set_has_backendname();
    backendname_ = backendname;
  } else {
    clear_has_backendname();
    backendname_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:NodesManager.Protocol.OnNodeRejectedTopic.BackEndName)
}

// -------------------------------------------------------------------

// OnNodeUnavaliable

// optional string Node = 1;
inline bool OnNodeUnavaliable::has_node() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void OnNodeUnavaliable::set_has_node() {
  _has_bits_[0] |= 0x00000001u;
}
inline void OnNodeUnavaliable::clear_has_node() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void OnNodeUnavaliable::clear_node() {
  if (node_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    node_->clear();
  }
  clear_has_node();
}
inline const ::std::string& OnNodeUnavaliable::node() const {
  // @@protoc_insertion_point(field_get:NodesManager.Protocol.OnNodeUnavaliable.Node)
  return *node_;
}
inline void OnNodeUnavaliable::set_node(const ::std::string& value) {
  set_has_node();
  if (node_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    node_ = new ::std::string;
  }
  node_->assign(value);
  // @@protoc_insertion_point(field_set:NodesManager.Protocol.OnNodeUnavaliable.Node)
}
inline void OnNodeUnavaliable::set_node(const char* value) {
  set_has_node();
  if (node_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    node_ = new ::std::string;
  }
  node_->assign(value);
  // @@protoc_insertion_point(field_set_char:NodesManager.Protocol.OnNodeUnavaliable.Node)
}
inline void OnNodeUnavaliable::set_node(const char* value, size_t size) {
  set_has_node();
  if (node_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    node_ = new ::std::string;
  }
  node_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:NodesManager.Protocol.OnNodeUnavaliable.Node)
}
inline ::std::string* OnNodeUnavaliable::mutable_node() {
  set_has_node();
  if (node_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    node_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:NodesManager.Protocol.OnNodeUnavaliable.Node)
  return node_;
}
inline ::std::string* OnNodeUnavaliable::release_node() {
  clear_has_node();
  if (node_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = node_;
    node_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void OnNodeUnavaliable::set_allocated_node(::std::string* node) {
  if (node_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete node_;
  }
  if (node) {
    set_has_node();
    node_ = node;
  } else {
    clear_has_node();
    node_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:NodesManager.Protocol.OnNodeUnavaliable.Node)
}

// optional string Pattern = 2;
inline bool OnNodeUnavaliable::has_pattern() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void OnNodeUnavaliable::set_has_pattern() {
  _has_bits_[0] |= 0x00000002u;
}
inline void OnNodeUnavaliable::clear_has_pattern() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void OnNodeUnavaliable::clear_pattern() {
  if (pattern_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    pattern_->clear();
  }
  clear_has_pattern();
}
inline const ::std::string& OnNodeUnavaliable::pattern() const {
  // @@protoc_insertion_point(field_get:NodesManager.Protocol.OnNodeUnavaliable.Pattern)
  return *pattern_;
}
inline void OnNodeUnavaliable::set_pattern(const ::std::string& value) {
  set_has_pattern();
  if (pattern_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    pattern_ = new ::std::string;
  }
  pattern_->assign(value);
  // @@protoc_insertion_point(field_set:NodesManager.Protocol.OnNodeUnavaliable.Pattern)
}
inline void OnNodeUnavaliable::set_pattern(const char* value) {
  set_has_pattern();
  if (pattern_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    pattern_ = new ::std::string;
  }
  pattern_->assign(value);
  // @@protoc_insertion_point(field_set_char:NodesManager.Protocol.OnNodeUnavaliable.Pattern)
}
inline void OnNodeUnavaliable::set_pattern(const char* value, size_t size) {
  set_has_pattern();
  if (pattern_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    pattern_ = new ::std::string;
  }
  pattern_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:NodesManager.Protocol.OnNodeUnavaliable.Pattern)
}
inline ::std::string* OnNodeUnavaliable::mutable_pattern() {
  set_has_pattern();
  if (pattern_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    pattern_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:NodesManager.Protocol.OnNodeUnavaliable.Pattern)
  return pattern_;
}
inline ::std::string* OnNodeUnavaliable::release_pattern() {
  clear_has_pattern();
  if (pattern_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = pattern_;
    pattern_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void OnNodeUnavaliable::set_allocated_pattern(::std::string* pattern) {
  if (pattern_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete pattern_;
  }
  if (pattern) {
    set_has_pattern();
    pattern_ = pattern;
  } else {
    clear_has_pattern();
    pattern_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:NodesManager.Protocol.OnNodeUnavaliable.Pattern)
}

// optional string Topic = 3;
inline bool OnNodeUnavaliable::has_topic() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void OnNodeUnavaliable::set_has_topic() {
  _has_bits_[0] |= 0x00000004u;
}
inline void OnNodeUnavaliable::clear_has_topic() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void OnNodeUnavaliable::clear_topic() {
  if (topic_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    topic_->clear();
  }
  clear_has_topic();
}
inline const ::std::string& OnNodeUnavaliable::topic() const {
  // @@protoc_insertion_point(field_get:NodesManager.Protocol.OnNodeUnavaliable.Topic)
  return *topic_;
}
inline void OnNodeUnavaliable::set_topic(const ::std::string& value) {
  set_has_topic();
  if (topic_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    topic_ = new ::std::string;
  }
  topic_->assign(value);
  // @@protoc_insertion_point(field_set:NodesManager.Protocol.OnNodeUnavaliable.Topic)
}
inline void OnNodeUnavaliable::set_topic(const char* value) {
  set_has_topic();
  if (topic_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    topic_ = new ::std::string;
  }
  topic_->assign(value);
  // @@protoc_insertion_point(field_set_char:NodesManager.Protocol.OnNodeUnavaliable.Topic)
}
inline void OnNodeUnavaliable::set_topic(const char* value, size_t size) {
  set_has_topic();
  if (topic_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    topic_ = new ::std::string;
  }
  topic_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:NodesManager.Protocol.OnNodeUnavaliable.Topic)
}
inline ::std::string* OnNodeUnavaliable::mutable_topic() {
  set_has_topic();
  if (topic_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    topic_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:NodesManager.Protocol.OnNodeUnavaliable.Topic)
  return topic_;
}
inline ::std::string* OnNodeUnavaliable::release_topic() {
  clear_has_topic();
  if (topic_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = topic_;
    topic_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void OnNodeUnavaliable::set_allocated_topic(::std::string* topic) {
  if (topic_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete topic_;
  }
  if (topic) {
    set_has_topic();
    topic_ = topic;
  } else {
    clear_has_topic();
    topic_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:NodesManager.Protocol.OnNodeUnavaliable.Topic)
}

// optional string BackEndName = 4;
inline bool OnNodeUnavaliable::has_backendname() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void OnNodeUnavaliable::set_has_backendname() {
  _has_bits_[0] |= 0x00000008u;
}
inline void OnNodeUnavaliable::clear_has_backendname() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void OnNodeUnavaliable::clear_backendname() {
  if (backendname_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    backendname_->clear();
  }
  clear_has_backendname();
}
inline const ::std::string& OnNodeUnavaliable::backendname() const {
  // @@protoc_insertion_point(field_get:NodesManager.Protocol.OnNodeUnavaliable.BackEndName)
  return *backendname_;
}
inline void OnNodeUnavaliable::set_backendname(const ::std::string& value) {
  set_has_backendname();
  if (backendname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    backendname_ = new ::std::string;
  }
  backendname_->assign(value);
  // @@protoc_insertion_point(field_set:NodesManager.Protocol.OnNodeUnavaliable.BackEndName)
}
inline void OnNodeUnavaliable::set_backendname(const char* value) {
  set_has_backendname();
  if (backendname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    backendname_ = new ::std::string;
  }
  backendname_->assign(value);
  // @@protoc_insertion_point(field_set_char:NodesManager.Protocol.OnNodeUnavaliable.BackEndName)
}
inline void OnNodeUnavaliable::set_backendname(const char* value, size_t size) {
  set_has_backendname();
  if (backendname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    backendname_ = new ::std::string;
  }
  backendname_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:NodesManager.Protocol.OnNodeUnavaliable.BackEndName)
}
inline ::std::string* OnNodeUnavaliable::mutable_backendname() {
  set_has_backendname();
  if (backendname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    backendname_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:NodesManager.Protocol.OnNodeUnavaliable.BackEndName)
  return backendname_;
}
inline ::std::string* OnNodeUnavaliable::release_backendname() {
  clear_has_backendname();
  if (backendname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = backendname_;
    backendname_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void OnNodeUnavaliable::set_allocated_backendname(::std::string* backendname) {
  if (backendname_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete backendname_;
  }
  if (backendname) {
    set_has_backendname();
    backendname_ = backendname;
  } else {
    clear_has_backendname();
    backendname_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:NodesManager.Protocol.OnNodeUnavaliable.BackEndName)
}

// -------------------------------------------------------------------

// RejectTopic

// optional string Pattern = 1;
inline bool RejectTopic::has_pattern() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RejectTopic::set_has_pattern() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RejectTopic::clear_has_pattern() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RejectTopic::clear_pattern() {
  if (pattern_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    pattern_->clear();
  }
  clear_has_pattern();
}
inline const ::std::string& RejectTopic::pattern() const {
  // @@protoc_insertion_point(field_get:NodesManager.Protocol.RejectTopic.Pattern)
  return *pattern_;
}
inline void RejectTopic::set_pattern(const ::std::string& value) {
  set_has_pattern();
  if (pattern_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    pattern_ = new ::std::string;
  }
  pattern_->assign(value);
  // @@protoc_insertion_point(field_set:NodesManager.Protocol.RejectTopic.Pattern)
}
inline void RejectTopic::set_pattern(const char* value) {
  set_has_pattern();
  if (pattern_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    pattern_ = new ::std::string;
  }
  pattern_->assign(value);
  // @@protoc_insertion_point(field_set_char:NodesManager.Protocol.RejectTopic.Pattern)
}
inline void RejectTopic::set_pattern(const char* value, size_t size) {
  set_has_pattern();
  if (pattern_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    pattern_ = new ::std::string;
  }
  pattern_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:NodesManager.Protocol.RejectTopic.Pattern)
}
inline ::std::string* RejectTopic::mutable_pattern() {
  set_has_pattern();
  if (pattern_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    pattern_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:NodesManager.Protocol.RejectTopic.Pattern)
  return pattern_;
}
inline ::std::string* RejectTopic::release_pattern() {
  clear_has_pattern();
  if (pattern_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = pattern_;
    pattern_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void RejectTopic::set_allocated_pattern(::std::string* pattern) {
  if (pattern_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete pattern_;
  }
  if (pattern) {
    set_has_pattern();
    pattern_ = pattern;
  } else {
    clear_has_pattern();
    pattern_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:NodesManager.Protocol.RejectTopic.Pattern)
}

// optional string Topic = 2;
inline bool RejectTopic::has_topic() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RejectTopic::set_has_topic() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RejectTopic::clear_has_topic() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RejectTopic::clear_topic() {
  if (topic_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    topic_->clear();
  }
  clear_has_topic();
}
inline const ::std::string& RejectTopic::topic() const {
  // @@protoc_insertion_point(field_get:NodesManager.Protocol.RejectTopic.Topic)
  return *topic_;
}
inline void RejectTopic::set_topic(const ::std::string& value) {
  set_has_topic();
  if (topic_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    topic_ = new ::std::string;
  }
  topic_->assign(value);
  // @@protoc_insertion_point(field_set:NodesManager.Protocol.RejectTopic.Topic)
}
inline void RejectTopic::set_topic(const char* value) {
  set_has_topic();
  if (topic_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    topic_ = new ::std::string;
  }
  topic_->assign(value);
  // @@protoc_insertion_point(field_set_char:NodesManager.Protocol.RejectTopic.Topic)
}
inline void RejectTopic::set_topic(const char* value, size_t size) {
  set_has_topic();
  if (topic_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    topic_ = new ::std::string;
  }
  topic_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:NodesManager.Protocol.RejectTopic.Topic)
}
inline ::std::string* RejectTopic::mutable_topic() {
  set_has_topic();
  if (topic_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    topic_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:NodesManager.Protocol.RejectTopic.Topic)
  return topic_;
}
inline ::std::string* RejectTopic::release_topic() {
  clear_has_topic();
  if (topic_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = topic_;
    topic_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void RejectTopic::set_allocated_topic(::std::string* topic) {
  if (topic_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete topic_;
  }
  if (topic) {
    set_has_topic();
    topic_ = topic;
  } else {
    clear_has_topic();
    topic_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:NodesManager.Protocol.RejectTopic.Topic)
}

// optional string BackEndName = 3;
inline bool RejectTopic::has_backendname() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void RejectTopic::set_has_backendname() {
  _has_bits_[0] |= 0x00000004u;
}
inline void RejectTopic::clear_has_backendname() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void RejectTopic::clear_backendname() {
  if (backendname_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    backendname_->clear();
  }
  clear_has_backendname();
}
inline const ::std::string& RejectTopic::backendname() const {
  // @@protoc_insertion_point(field_get:NodesManager.Protocol.RejectTopic.BackEndName)
  return *backendname_;
}
inline void RejectTopic::set_backendname(const ::std::string& value) {
  set_has_backendname();
  if (backendname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    backendname_ = new ::std::string;
  }
  backendname_->assign(value);
  // @@protoc_insertion_point(field_set:NodesManager.Protocol.RejectTopic.BackEndName)
}
inline void RejectTopic::set_backendname(const char* value) {
  set_has_backendname();
  if (backendname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    backendname_ = new ::std::string;
  }
  backendname_->assign(value);
  // @@protoc_insertion_point(field_set_char:NodesManager.Protocol.RejectTopic.BackEndName)
}
inline void RejectTopic::set_backendname(const char* value, size_t size) {
  set_has_backendname();
  if (backendname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    backendname_ = new ::std::string;
  }
  backendname_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:NodesManager.Protocol.RejectTopic.BackEndName)
}
inline ::std::string* RejectTopic::mutable_backendname() {
  set_has_backendname();
  if (backendname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    backendname_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:NodesManager.Protocol.RejectTopic.BackEndName)
  return backendname_;
}
inline ::std::string* RejectTopic::release_backendname() {
  clear_has_backendname();
  if (backendname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = backendname_;
    backendname_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void RejectTopic::set_allocated_backendname(::std::string* backendname) {
  if (backendname_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete backendname_;
  }
  if (backendname) {
    set_has_backendname();
    backendname_ = backendname;
  } else {
    clear_has_backendname();
    backendname_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:NodesManager.Protocol.RejectTopic.BackEndName)
}

// -------------------------------------------------------------------

// Subscribe

// optional string Pattern = 1;
inline bool Subscribe::has_pattern() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Subscribe::set_has_pattern() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Subscribe::clear_has_pattern() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Subscribe::clear_pattern() {
  if (pattern_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    pattern_->clear();
  }
  clear_has_pattern();
}
inline const ::std::string& Subscribe::pattern() const {
  // @@protoc_insertion_point(field_get:NodesManager.Protocol.Subscribe.Pattern)
  return *pattern_;
}
inline void Subscribe::set_pattern(const ::std::string& value) {
  set_has_pattern();
  if (pattern_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    pattern_ = new ::std::string;
  }
  pattern_->assign(value);
  // @@protoc_insertion_point(field_set:NodesManager.Protocol.Subscribe.Pattern)
}
inline void Subscribe::set_pattern(const char* value) {
  set_has_pattern();
  if (pattern_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    pattern_ = new ::std::string;
  }
  pattern_->assign(value);
  // @@protoc_insertion_point(field_set_char:NodesManager.Protocol.Subscribe.Pattern)
}
inline void Subscribe::set_pattern(const char* value, size_t size) {
  set_has_pattern();
  if (pattern_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    pattern_ = new ::std::string;
  }
  pattern_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:NodesManager.Protocol.Subscribe.Pattern)
}
inline ::std::string* Subscribe::mutable_pattern() {
  set_has_pattern();
  if (pattern_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    pattern_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:NodesManager.Protocol.Subscribe.Pattern)
  return pattern_;
}
inline ::std::string* Subscribe::release_pattern() {
  clear_has_pattern();
  if (pattern_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = pattern_;
    pattern_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void Subscribe::set_allocated_pattern(::std::string* pattern) {
  if (pattern_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete pattern_;
  }
  if (pattern) {
    set_has_pattern();
    pattern_ = pattern;
  } else {
    clear_has_pattern();
    pattern_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:NodesManager.Protocol.Subscribe.Pattern)
}

// optional string Topic = 2;
inline bool Subscribe::has_topic() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Subscribe::set_has_topic() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Subscribe::clear_has_topic() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Subscribe::clear_topic() {
  if (topic_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    topic_->clear();
  }
  clear_has_topic();
}
inline const ::std::string& Subscribe::topic() const {
  // @@protoc_insertion_point(field_get:NodesManager.Protocol.Subscribe.Topic)
  return *topic_;
}
inline void Subscribe::set_topic(const ::std::string& value) {
  set_has_topic();
  if (topic_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    topic_ = new ::std::string;
  }
  topic_->assign(value);
  // @@protoc_insertion_point(field_set:NodesManager.Protocol.Subscribe.Topic)
}
inline void Subscribe::set_topic(const char* value) {
  set_has_topic();
  if (topic_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    topic_ = new ::std::string;
  }
  topic_->assign(value);
  // @@protoc_insertion_point(field_set_char:NodesManager.Protocol.Subscribe.Topic)
}
inline void Subscribe::set_topic(const char* value, size_t size) {
  set_has_topic();
  if (topic_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    topic_ = new ::std::string;
  }
  topic_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:NodesManager.Protocol.Subscribe.Topic)
}
inline ::std::string* Subscribe::mutable_topic() {
  set_has_topic();
  if (topic_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    topic_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:NodesManager.Protocol.Subscribe.Topic)
  return topic_;
}
inline ::std::string* Subscribe::release_topic() {
  clear_has_topic();
  if (topic_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = topic_;
    topic_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void Subscribe::set_allocated_topic(::std::string* topic) {
  if (topic_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete topic_;
  }
  if (topic) {
    set_has_topic();
    topic_ = topic;
  } else {
    clear_has_topic();
    topic_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:NodesManager.Protocol.Subscribe.Topic)
}

// optional string BackEndName = 3;
inline bool Subscribe::has_backendname() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Subscribe::set_has_backendname() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Subscribe::clear_has_backendname() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Subscribe::clear_backendname() {
  if (backendname_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    backendname_->clear();
  }
  clear_has_backendname();
}
inline const ::std::string& Subscribe::backendname() const {
  // @@protoc_insertion_point(field_get:NodesManager.Protocol.Subscribe.BackEndName)
  return *backendname_;
}
inline void Subscribe::set_backendname(const ::std::string& value) {
  set_has_backendname();
  if (backendname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    backendname_ = new ::std::string;
  }
  backendname_->assign(value);
  // @@protoc_insertion_point(field_set:NodesManager.Protocol.Subscribe.BackEndName)
}
inline void Subscribe::set_backendname(const char* value) {
  set_has_backendname();
  if (backendname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    backendname_ = new ::std::string;
  }
  backendname_->assign(value);
  // @@protoc_insertion_point(field_set_char:NodesManager.Protocol.Subscribe.BackEndName)
}
inline void Subscribe::set_backendname(const char* value, size_t size) {
  set_has_backendname();
  if (backendname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    backendname_ = new ::std::string;
  }
  backendname_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:NodesManager.Protocol.Subscribe.BackEndName)
}
inline ::std::string* Subscribe::mutable_backendname() {
  set_has_backendname();
  if (backendname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    backendname_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:NodesManager.Protocol.Subscribe.BackEndName)
  return backendname_;
}
inline ::std::string* Subscribe::release_backendname() {
  clear_has_backendname();
  if (backendname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = backendname_;
    backendname_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void Subscribe::set_allocated_backendname(::std::string* backendname) {
  if (backendname_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete backendname_;
  }
  if (backendname) {
    set_has_backendname();
    backendname_ = backendname;
  } else {
    clear_has_backendname();
    backendname_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:NodesManager.Protocol.Subscribe.BackEndName)
}

// -------------------------------------------------------------------

// UnSubscribe

// optional string Pattern = 1;
inline bool UnSubscribe::has_pattern() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void UnSubscribe::set_has_pattern() {
  _has_bits_[0] |= 0x00000001u;
}
inline void UnSubscribe::clear_has_pattern() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void UnSubscribe::clear_pattern() {
  if (pattern_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    pattern_->clear();
  }
  clear_has_pattern();
}
inline const ::std::string& UnSubscribe::pattern() const {
  // @@protoc_insertion_point(field_get:NodesManager.Protocol.UnSubscribe.Pattern)
  return *pattern_;
}
inline void UnSubscribe::set_pattern(const ::std::string& value) {
  set_has_pattern();
  if (pattern_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    pattern_ = new ::std::string;
  }
  pattern_->assign(value);
  // @@protoc_insertion_point(field_set:NodesManager.Protocol.UnSubscribe.Pattern)
}
inline void UnSubscribe::set_pattern(const char* value) {
  set_has_pattern();
  if (pattern_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    pattern_ = new ::std::string;
  }
  pattern_->assign(value);
  // @@protoc_insertion_point(field_set_char:NodesManager.Protocol.UnSubscribe.Pattern)
}
inline void UnSubscribe::set_pattern(const char* value, size_t size) {
  set_has_pattern();
  if (pattern_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    pattern_ = new ::std::string;
  }
  pattern_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:NodesManager.Protocol.UnSubscribe.Pattern)
}
inline ::std::string* UnSubscribe::mutable_pattern() {
  set_has_pattern();
  if (pattern_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    pattern_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:NodesManager.Protocol.UnSubscribe.Pattern)
  return pattern_;
}
inline ::std::string* UnSubscribe::release_pattern() {
  clear_has_pattern();
  if (pattern_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = pattern_;
    pattern_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void UnSubscribe::set_allocated_pattern(::std::string* pattern) {
  if (pattern_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete pattern_;
  }
  if (pattern) {
    set_has_pattern();
    pattern_ = pattern;
  } else {
    clear_has_pattern();
    pattern_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:NodesManager.Protocol.UnSubscribe.Pattern)
}

// optional string Topic = 2;
inline bool UnSubscribe::has_topic() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void UnSubscribe::set_has_topic() {
  _has_bits_[0] |= 0x00000002u;
}
inline void UnSubscribe::clear_has_topic() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void UnSubscribe::clear_topic() {
  if (topic_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    topic_->clear();
  }
  clear_has_topic();
}
inline const ::std::string& UnSubscribe::topic() const {
  // @@protoc_insertion_point(field_get:NodesManager.Protocol.UnSubscribe.Topic)
  return *topic_;
}
inline void UnSubscribe::set_topic(const ::std::string& value) {
  set_has_topic();
  if (topic_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    topic_ = new ::std::string;
  }
  topic_->assign(value);
  // @@protoc_insertion_point(field_set:NodesManager.Protocol.UnSubscribe.Topic)
}
inline void UnSubscribe::set_topic(const char* value) {
  set_has_topic();
  if (topic_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    topic_ = new ::std::string;
  }
  topic_->assign(value);
  // @@protoc_insertion_point(field_set_char:NodesManager.Protocol.UnSubscribe.Topic)
}
inline void UnSubscribe::set_topic(const char* value, size_t size) {
  set_has_topic();
  if (topic_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    topic_ = new ::std::string;
  }
  topic_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:NodesManager.Protocol.UnSubscribe.Topic)
}
inline ::std::string* UnSubscribe::mutable_topic() {
  set_has_topic();
  if (topic_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    topic_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:NodesManager.Protocol.UnSubscribe.Topic)
  return topic_;
}
inline ::std::string* UnSubscribe::release_topic() {
  clear_has_topic();
  if (topic_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = topic_;
    topic_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void UnSubscribe::set_allocated_topic(::std::string* topic) {
  if (topic_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete topic_;
  }
  if (topic) {
    set_has_topic();
    topic_ = topic;
  } else {
    clear_has_topic();
    topic_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:NodesManager.Protocol.UnSubscribe.Topic)
}

// optional string BackEndName = 3;
inline bool UnSubscribe::has_backendname() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void UnSubscribe::set_has_backendname() {
  _has_bits_[0] |= 0x00000004u;
}
inline void UnSubscribe::clear_has_backendname() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void UnSubscribe::clear_backendname() {
  if (backendname_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    backendname_->clear();
  }
  clear_has_backendname();
}
inline const ::std::string& UnSubscribe::backendname() const {
  // @@protoc_insertion_point(field_get:NodesManager.Protocol.UnSubscribe.BackEndName)
  return *backendname_;
}
inline void UnSubscribe::set_backendname(const ::std::string& value) {
  set_has_backendname();
  if (backendname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    backendname_ = new ::std::string;
  }
  backendname_->assign(value);
  // @@protoc_insertion_point(field_set:NodesManager.Protocol.UnSubscribe.BackEndName)
}
inline void UnSubscribe::set_backendname(const char* value) {
  set_has_backendname();
  if (backendname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    backendname_ = new ::std::string;
  }
  backendname_->assign(value);
  // @@protoc_insertion_point(field_set_char:NodesManager.Protocol.UnSubscribe.BackEndName)
}
inline void UnSubscribe::set_backendname(const char* value, size_t size) {
  set_has_backendname();
  if (backendname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    backendname_ = new ::std::string;
  }
  backendname_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:NodesManager.Protocol.UnSubscribe.BackEndName)
}
inline ::std::string* UnSubscribe::mutable_backendname() {
  set_has_backendname();
  if (backendname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    backendname_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:NodesManager.Protocol.UnSubscribe.BackEndName)
  return backendname_;
}
inline ::std::string* UnSubscribe::release_backendname() {
  clear_has_backendname();
  if (backendname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = backendname_;
    backendname_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void UnSubscribe::set_allocated_backendname(::std::string* backendname) {
  if (backendname_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete backendname_;
  }
  if (backendname) {
    set_has_backendname();
    backendname_ = backendname;
  } else {
    clear_has_backendname();
    backendname_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:NodesManager.Protocol.UnSubscribe.BackEndName)
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace Protocol
}  // namespace NodesManager

#ifndef SWIG
namespace google {
namespace protobuf {


}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_NodeManagerProtocol_2eproto__INCLUDED
